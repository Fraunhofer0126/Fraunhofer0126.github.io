<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Mardown语法教程</title>
    <url>/2020/08/03/Mardown%E8%AF%AD%E6%B3%95%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<h3 id="转载-点击阅读原文"><a href="#转载-点击阅读原文" class="headerlink" title="转载 点击阅读原文"></a>转载 <a href="https://www.jianshu.com/p/ebe52d2d468f" title="原文链接">点击阅读原文</a></h3></blockquote>
]]></content>
      <categories>
        <category>Reference</category>
      </categories>
      <tags>
        <tag>blog</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包(持续更新)</title>
    <url>/2020/08/06/01%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<h1 id="01背包模板"><a href="#01背包模板" class="headerlink" title="01背包模板"></a>01背包模板</h1><a id="more"></a>

<p>状态转移方程：<strong>F[i,v] = max{F[i−1,v],F[i−1,v−Ci] + Wi}</strong><br>每种物品只有一件，所以只要它考虑选不选，不选就递归子问题i-1件选不选<br>选就递归另一个子问题，第i件选择后背包容量减少&amp;&amp;i-1件选不选(当然要取二者的最大值)</p>
<p>二维要用个dp二维数组来记忆化储存，以防重复计算超时</p>
<ul>
<li><p><strong>dp[i][j]意思是轮到第i件物品，背包容量还剩j，背包总价值</strong></p>
</li>
<li><p><strong>f[j]意思也是还剩j，背包总价值</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T是背包容量，M是总数</span></span><br><span class="line"><span class="keyword">int</span> T,M;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">105</span>],v[<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1005</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维递归版,需要传参</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one_zero_pack</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> capacity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dp[i][capacity])</span><br><span class="line">        <span class="keyword">return</span> dp[i][capacity];</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span> || capacity == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(w[i] &gt; capacity)</span><br><span class="line">        <span class="comment">//装不下，下一个</span></span><br><span class="line">        <span class="keyword">return</span> one_zero_pack(i<span class="number">-1</span>, capacity);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i][capacity] = max(one_zero_pack(i<span class="number">-1</span>,capacity), one_zero_pack(i<span class="number">-1</span>,capacity-w[i])+v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维递推版，不需要传参</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one_zero_pack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//画表过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i]) dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i<span class="number">-1</span>][j-w[i]]+v[i]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[M][T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>一维递推版，空间优化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">one_zero_pack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = T; j &gt;= w[i]; j--) <span class="comment">//逆序</span></span><br><span class="line">            f[j] = max(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">    <span class="keyword">return</span> f[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数随便写写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;one_zero_pack()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//该传参传参</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>LCA模板总结</title>
    <url>/2020/08/10/LCA%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> tot=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> head[maxn],d[maxn],p[maxn][<span class="number">21</span>];<span class="comment">//head数组就是链接表标配了吧？d存的是深度（deep）,p[i][j]存的[i]向上走2的j次方那么长的路径</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to,next;</span><br><span class="line">&#125;e[maxn*<span class="number">2</span>];<span class="comment">//存树</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[tot].to=v;</span><br><span class="line">    e[tot].next=head[u];</span><br><span class="line">    head[u]=tot++;</span><br><span class="line">&#125;               <span class="comment">//加边函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u,<span class="keyword">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d[u]=d[father]+<span class="number">1</span>;</span><br><span class="line">    p[u][<span class="number">0</span>]=father;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=d[u];i++)</span><br><span class="line">        p[u][i]=p[p[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i!=<span class="number">-1</span>; i=e[i].next)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[i].to != father)</span><br><span class="line">            dfs(e[i].to, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><figcaption><span> </span><a href="//首先进行的预处理，将所有点的deep和p的初始值dfs出来">link</a></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>                                          <span class="comment">//非常标准的lca查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(d[a]&gt;d[b])</span><br><span class="line">        swap(a,b);           <span class="comment">//保证a是在b结点上方，即a的深度小于b的深度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">        <span class="keyword">if</span>(d[a]&lt;=d[b]-(<span class="number">1</span>&lt;&lt;i))</span><br><span class="line">            b=p[b][i];             <span class="comment">//先把b移到和a同一个深度</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)</span><br><span class="line">        <span class="keyword">return</span> a;                 <span class="comment">//特判，如果b上来和就和a一样了，那就可以直接返回答案了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">20</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p[a][i]==p[b][i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a=p[a][i],b=p[b][i];           <span class="comment">//A和B一起上移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p[a][<span class="number">0</span>];               <span class="comment">//找出最后a值的数字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>LCA</tag>
        <tag>倍增算法</tag>
      </tags>
  </entry>
  <entry>
    <title>[习题]DP+单调队列 LOJ10180</title>
    <url>/2020/08/08/%5B%E4%B9%A0%E9%A2%98%5DDP+%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97LOJ10180/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="烽火传递"><a href="#烽火传递" class="headerlink" title="烽火传递"></a>烽火传递</h1><p>烽火台是重要的军事防御设施，一般建在交通要道或险要处。一旦有军情发生，则白天用浓烟，晚上有火光传递军情。</p>
<p>在某两个城市之间有 n 座烽火台，每个烽火台发出信号都有一定的代价。为了使情报准确传递，在连续 m 个烽火台中至少要有一个发出信号。现在输入 n,m 和每个烽火台的代价，请计算总共最少的代价在两城市之间来准确传递情报。</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行是 n,m，表示 n 个烽火台和连续烽火台数 m；<br>第二行 n 个整数表示每个烽火台的代价 ai。</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>输出仅一个整数，表示最小代价。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
5 3<br/>
1 2 5 6 2
</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
4
</blockquote>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l,r,a[N],f[N],q[N&lt;&lt;<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>本来做法</p>
<ol>
<li>f[i]表示1-i烽火台的最小代价<br>转移方程是这样<blockquote>
f[i] = min(f[i], f[j] + a[k])<br/>
i-2m+1 <= j <= i-m<br/>
i-m+1 <= k <= j+m
</blockquote></li>
<li>哎但这样当前状态是不确定的，也就没有所谓“状态转移”<br/><br>网上搬运的代码<br/><br>考虑f[i]是第i个烽火台点火时，1-i烽火台最小代价<blockquote>
<p>10 3<br/><br>1 2 5 6 2 1 2 5 6 2<br/><br>f[1] = f[0] + a[1] = 0 + a[1] = 1点第一个台子，最小代价就是它本身<br/><br>f[2] = 2 <br/><br>f[3] = 5 <br/><br>f[4] = 6 + 1 = 7 <br/><br>f[5] = 2 + 2 = 4 <br/><br>f[6] = 1 + 4 = 5 <br/><br>f[7] = 2 + 4 = 6 <br/><br>f[8] = 5 + 4 = 9 <br/><br>f[9] = 6 + 5 = 11 <br/><br>f[10] = 2 + 6 = 8 <br/></p>
</blockquote>
</li>
</ol>
<p><strong>感觉其实有点像lis问题，也是在前面的一定区间内寻找已经解决掉的子问题的最优解</strong></p>
<blockquote>
f[i] = min(f[j]) + a[i]<br/>
i-m <= j <= i-1 
</blockquote>


<h2 id="使用单调队列优化了复杂度O-n-否则两重循环O-mn"><a href="#使用单调队列优化了复杂度O-n-否则两重循环O-mn" class="headerlink" title="使用单调队列优化了复杂度O(n),否则两重循环O(mn)"></a>使用单调队列优化了复杂度O(n),否则两重循环O(mn)</h2><p><strong>这道题并不能用线段树优化，因为树是建在已知数组上的，而求的是f[j]的最小值，f在实时更新，而建树的复杂度是O(2^n)，不可能更新一次建一次</strong><br/></p>
<p>f[q[l]]代表[i-m,i-1]的f的最小值<br/></p>
<p>q[l]不能与a[i]重合，所以转移状态应该在入队列之前<br/><br>用数组模拟队列nb</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    l = r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>( ;l &lt; r &amp;&amp; i - q[l] &gt; m; l++);</span><br><span class="line">        f[i] = f[q[l]] + a[i];</span><br><span class="line">        <span class="keyword">for</span>( ;l &lt; r &amp;&amp; f[q[r]] &gt; f[i]; r--);</span><br><span class="line">        q[++r] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最后答案在区间[n-m+1, n]里找</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    dfs();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n - m + <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ans = min(ans, f[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>[习题]并查集POJ1182</title>
    <url>/2020/08/04/%5B%E4%B9%A0%E9%A2%98%5D%E5%B9%B6%E6%9F%A5%E9%9B%86POJ1182/</url>
    <content><![CDATA[<h1 id="食物链"><a href="#食物链" class="headerlink" title="食物链"></a>食物链</h1><p>动物王国中有三类动物A,B,C，这三类动物的食物链构成了有趣的环形。A吃B， B吃C，C吃A。<br/><br>现有N个动物，以1－N编号。每个动物都是A,B,C中的一种，但是我们并不知道它到底是哪一种。<br/><br>有人用两种说法对这N个动物所构成的食物链关系进行描述：<br/><br>第一种说法是”1 X Y”，表示X和Y是同类。<br/><br>第二种说法是”2 X Y”，表示X吃Y。<br/><br>此人对N个动物，用上述两种说法，一句接一句地说出K句话，这K句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。<br/><br>1） 当前的话与前面的某些真的话冲突，就是假话；<br/><br>2） 当前的话中X或Y比N大，就是假话；<br/><br>3） 当前的话表示X吃X，就是假话。<br/><br>你的任务是根据给定的N（1 &lt;= N &lt;= 50,000）和K句话（0 &lt;= K &lt;= 100,000），输出假话的总数。<br/></p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>第一行是两个整数N和K，以一个空格分隔。<br/><br>以下K行每行是三个正整数 D，X，Y，两数之间用一个空格隔开，其中D表示说法的种类。<br/><br>若D=1，则表示X和Y是同类。<br/><br>若D=2，则表示X吃Y。<br/></p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>只有一个整数，表示假话的数目。</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
100 7<br/>
1 101 1   <br/>
2 1 2   <br/>
2 2 3    <br/>
2 3 3 <br/>
1 1 3 <br/>
2 3 1 <br/>
1 5 5<br/>
</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
3
</blockquote>

<h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 50010</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> pre;</span><br><span class="line">    <span class="keyword">int</span> relation;</span><br><span class="line">&#125;;</span><br><span class="line">node p[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//查找根结点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">if</span>(x == p[x].pre)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    temp = p[x].pre; <span class="comment">//路径压缩</span></span><br><span class="line">    p[x].pre = find(temp);</span><br><span class="line">    p[x].relation = (p[x].relation + p[temp].relation) % <span class="number">3</span>; <span class="comment">//关系域更新</span></span><br><span class="line">    <span class="keyword">return</span> p[x].pre; <span class="comment">//根结点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="keyword">int</span> ope, a, b;</span><br><span class="line">    <span class="keyword">int</span> root1, root2;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//假话数量</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="comment">//初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        p[i].pre = i;</span><br><span class="line">        p[i].relation = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;ope, &amp;a, &amp;b);</span><br><span class="line">        <span class="keyword">if</span>(a &gt; n || b &gt; n) <span class="comment">//条件2</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ope == <span class="number">2</span> &amp;&amp; a == b) <span class="comment">//条件3</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//压缩路径后，a、b分别直接是root1,root2儿子</span></span><br><span class="line">        root1 = find(a);</span><br><span class="line">        root2 = find(b);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果不同根，就合并，暂时无法判断关系</span></span><br><span class="line">        <span class="comment">//同根就马上判断</span></span><br><span class="line">        <span class="keyword">if</span>(root1 != root2) <span class="comment">// 合并</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[root2].pre = root1;</span><br><span class="line">            p[root2].relation = (<span class="number">3</span> + (ope - <span class="number">1</span>) +p[a].relation - p[b].relation) % <span class="number">3</span>; <span class="comment">//%3是保证[0,2]</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ope == <span class="number">1</span> &amp;&amp; p[a].relation != p[b].relation)</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ope == <span class="number">2</span> &amp;&amp; ((<span class="number">3</span> - p[a].relation + p[b].relation) % <span class="number">3</span> != ope - <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                sum++;</span><br><span class="line">                <span class="keyword">continue</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h2>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>lcs问题</title>
    <url>/2020/08/08/lcs%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>lcs是<strong>最长公共子序列</strong>的缩写，用dp思想求解 (“子序列”可以不连续,而”子串”是连续的)<br/><br>看两个字符串 s1: BDCABA   s2: ABCBDAB <br/><br>他们俩的lcs是 BDAB、BCBA、BCAB等等<br/></p>
<p>下面以lcs为BCBA为例</p>

<p>s1: <strong>B</strong>D<strong>C</strong>A<strong>BA</strong>   s2: A<strong>BCB</strong>D<strong>A</strong>B</p>
<h2 id="问题是如何求解？"><a href="#问题是如何求解？" class="headerlink" title="问题是如何求解？"></a>问题是如何求解？</h2><ul>
<li>状态的表示<br/><br>引入一个二维数组dp, dp[i][j] 表示 s1从1<del>i的字串和 s2从1</del>j的子串的lcs<br/><br>(线性dp一般用递推，而树形一般用递归，这里用递推 )</li>
<li>状态的转移–递推<br/></li>
</ul>
<ol>
<li>dp的基本思想是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解<br/><br>递推我们就先考虑子问题，从dp[1][1]开始，如果s1[1]!=s2[1]，那dp[1][1]=0</br><br>如果s1[1]==s2[1]，那dp[1][1]=1对吧？那如果s1[1]!=s2[2]呢？dp[1][2]=?</br><br>显然是1而不是0，因为s2[1~2]的子序列s2[1]与s1[1]已经有公共子序列了，依此类推</br></li>
<li>那么我们现在考虑稍微靠后一点的dp[i][j]</br><br>如果s1[i]==s2[j]我们有</br></li>
</ol>
<blockquote>
<p><strong>dp[i][j] = dp[i-1][j-1] + 1</strong><br/></p>
</blockquote>
<p>也就是比s1,s2分别去掉这两个相同字母的序列的lcs大1！！<br/><br>那如果s1[i]!=s2[j]呢？</br><br>造成不相等的肯定是s1[i]或者s2[j],但又不确定是哪个造成的，不知道去掉其中一个(s1[i])，另一个(s2[j])会不会与(s1[i-1])相等<br/></p>
<blockquote>
<p><strong>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</strong><br/></p>
</blockquote>
<p>这就是两个状态转移方程</p>
<ol start="3">
<li>观察下图可以发现，向下或者向左或者向左下移动，dp[i][j]的值是不会减少的<br/><br>所以最后答案就是在dp[len1][len2]里，为最大长度.</li>
</ol>
<p><img src="http://img.51nod.com/upload/000FBEAF/08D25D565D85EFF40000000000000002.jpeg"></p>
<h1 id="HDU1503-Advanced-Fruits"><a href="#HDU1503-Advanced-Fruits" class="headerlink" title="HDU1503 Advanced Fruits"></a>HDU1503 Advanced Fruits</h1><p>The company “21st Century Fruits” has specialized in creating new sorts of fruits by transferring genes from one fruit into the genome of another one. Most times this method doesn’t work, but sometimes, in very rare cases, a new fruit emerges that tastes like a mixture between both of them.<br>A big topic of discussion inside the company is “How should the new creations be called?” A mixture between an apple and a pear could be called an apple-pear, of course, but this doesn’t sound very interesting. The boss finally decides to use the shortest string that contains both names of the original fruits as sub-strings as the new name. For instance, “applear” contains “apple” and “pear” (APPLEar and apPlEAR), and there is no shorter string that has the same property.</p>
<p>A combination of a cranberry and a boysenberry would therefore be called a “boysecranberry” or a “craboysenberry”, for example.</p>
<p>Your job is to write a program that computes such a shortest name for a combination of two given fruits. Your algorithm should be efficient, otherwise it is unlikely that it will execute in the alloted time for long fruit names.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>Each line of the input contains two strings that represent the names of the fruits that should be combined. All names have a maximum length of 100 and only consist of alphabetic characters.</p>
<p>Input is terminated by end of file.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case, output the shortest name of the resulting fruit on one line. If more than one shortest name is possible, any one is acceptable.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
apple peach<br/>
ananas banana<br/>
pear peach<br/>
</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
appleach<br/>
bananas<br/>
pearch<br/>
</blockquote>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAX = <span class="number">110</span>;</span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX];</span><br><span class="line"><span class="keyword">int</span> track[MAX][MAX];</span><br><span class="line"><span class="keyword">char</span> s1[MAX],s2[MAX],ans[MAX*<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> t = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h2 id="核心代码就是初始化，状态转移方程"><a href="#核心代码就是初始化，状态转移方程" class="headerlink" title="核心代码就是初始化，状态转移方程"></a>核心代码就是初始化，状态转移方程</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++)</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] == s2[j])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//track 1 表示左上</span></span><br><span class="line">                track[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s1[i] != s2[j])&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j<span class="number">-1</span>] &gt; dp[i<span class="number">-1</span>][j])&#123;</span><br><span class="line">                    dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="comment">//track 2 代表左</span></span><br><span class="line">                    track[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="comment">//track 3 代表上</span></span><br><span class="line">                    track[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="此题有个额外任务，不仅要给出lcs的数字答案，还要给出路径-共同序列-组合"><a href="#此题有个额外任务，不仅要给出lcs的数字答案，还要给出路径-共同序列-组合" class="headerlink" title="此题有个额外任务，不仅要给出lcs的数字答案，还要给出路径(共同序列+组合)"></a>此题有个额外任务，不仅要给出lcs的数字答案，还要给出路径(共同序列+组合)</h2><ul>
<li>只要用track二维数组记录每次从哪里转移来的(左，上，左上三个方向)<br>再从dp数组最右下角往回走就可以了</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">char</span> a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//给当前位置赋值，给下一位初始化</span></span><br><span class="line">    ans[t++]=a;</span><br><span class="line">    ans[t]=<span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printLCS</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dp[m][n])&#123;</span><br><span class="line">        <span class="keyword">if</span>(track[m][n] == <span class="number">1</span>)&#123;</span><br><span class="line">            add(s1[m]);</span><br><span class="line">            m--;n--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(track[m][n] == <span class="number">3</span>)&#123;</span><br><span class="line">                add(s1[m]);</span><br><span class="line">                m--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                add(s2[n]);</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m&gt;<span class="number">0</span>)add(s1[m--]);</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)add(s2[n--]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,s1+<span class="number">1</span>,s2+<span class="number">1</span>))&#123;</span><br><span class="line">        t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="built_in">strlen</span>(s1+<span class="number">1</span>), n = <span class="built_in">strlen</span>(s2+<span class="number">1</span>);</span><br><span class="line">        lcs(m,n);</span><br><span class="line">        printLCS(m, n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=t<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,ans[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>lcs</tag>
      </tags>
  </entry>
  <entry>
    <title>lis问题</title>
    <url>/2020/08/08/lis%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>lcs是<strong>最长递增子序列</strong>的缩写，用dp思想求解 (“子序列”可以不连续,而”子串”是连续的)<br/><br>我们看一个序列arr 1 7 3 5 9 4 8，它的lis是4<br/><br>最长递增子序列可以是 1 3 5 9 ，1 3 5 8， 1 3 4 8 (O(nlogn)是末尾越小越优,往下看)</p>
<h2 id="问题是如何求解？"><a href="#问题是如何求解？" class="headerlink" title="问题是如何求解？"></a>问题是如何求解？</h2><ul>
<li>状态的表示<br/><br>引入一个一维数组f, f[i] 表示arr 从1~i的lis<br/><br>(线性dp一般用递推，而树形一般用递归，这里用递推 )</li>
<li>状态的转移–递推<br/></li>
</ul>
<ol>
<li>dp的基本思想是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解<br/><br>递推我们就先考虑子问题，f[1]=1是肯定的，一个数的序列长度为1<br/><br>如果arr[2]&gt;arr[1], 那f[2]=f[1]+1=2; 如果arr[2]&lt;=arr[1]呢？<br/><br>就有arr[2]=1，应当重新从长度为1的子列开始计算<br/><br>那我们考虑稍微靠后的f[i],这时f[i]不能再和f[i-1]比较</li>
</ol>
<blockquote>
<p>8 3 5 2 6 7 9<br/><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i</p>
</blockquote>
<p>比如这样i位是6，前一位2是最小的f[i-1]=1,而6前面还有3 5构成 3 5 6，明显不对<br/></p>
<ol start="2">
<li>这时我们意识到一个循环i是不够的，需要再来一个j,两重循环<br/><br>i从1到len，j从1到i-1<br/><br>如果a[i]&gt;a[j]</li>
</ol>
<blockquote>
<p>f[i] = max(f[i], f[j]+1)</p>
</blockquote>
<p>状态转移方程很简单，找出前面的比它小的数字，然后“接上去”<br/><br>最后答案lis就是1~len的f[i]中的最大值</p>
<h1 id="O-n-2-算法"><a href="#O-n-2-算法" class="headerlink" title="O(n^2)算法"></a>O(n^2)算法</h1><p>很简单，没啥说的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="comment">//f[i] 表示以a[i]结尾的最长递增子序列长度</span></span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[i])&#123;</span><br><span class="line">                f[i] = max(f[i], f[j]+<span class="number">1</span>); <span class="comment">//状态转移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//ans = max&#123;f[1],f[2],....f[n]&#125;</span></span><br><span class="line">        ans = max(ans, f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="O-nlogn"><a href="#O-nlogn" class="headerlink" title="O(nlogn)"></a>O(nlogn)</h1><p>我们知道O(n^2)是很危险的，应该二分优化一下<br/><br>O(n^2)算法有两重循环，i循环不能优化，只能优化寻找小于arr[i]的元素的j循环<br/><br>这时采用另一种dp，设一维数组f, f[i]表示arr序列1~i内最长递增子序列的末尾数字的最小值<br>有点绕?<br/></p>
<p><strong>f[i]不再记录打断递增的序列了，而完完全全记录题目答案,这样就可以再f数组内用二分查找来选择用更小的arr元素替换f元素</strong><br/><br>而且不仅f的长度ans是题目答案，f本身内容也就是最长递增子序列的序列<br/><br>比如1 7 3 5 9 4 8<br/><br>输出长度是4<br>f的内容元素是 1 3 4 8 ,每一位都是保证最小的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//预处理</span></span><br><span class="line">f[<span class="number">1</span>] = arr[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">void</span> lis()&#123;</span><br><span class="line">    ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; f[ans])<span class="comment">//若a[i]&gt;f[ans]，直接把arr[i]接到后面</span></span><br><span class="line">            f[++ans]=arr[i];</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//否则，找到f中第一个&gt;=a[i]的位置f[j]，用arr[i]更新f[j]</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = lower_bound(f+<span class="number">1</span>,f+ans,arr[i]) - f;</span><br><span class="line">            f[pos] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="末尾-优化得牛逼！！"><a href="#末尾-优化得牛逼！！" class="headerlink" title="末尾 优化得牛逼！！"></a>末尾 优化得牛逼！！</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>lis</tag>
      </tags>
  </entry>
  <entry>
    <title>[习题]最短路HDU6797</title>
    <url>/2020/08/03/%5B%E4%B9%A0%E9%A2%98%5D%E6%9C%80%E7%9F%AD%E8%B7%AFHDU6797/</url>
    <content><![CDATA[<h1 id="Tokitsukaze-and-Rescue"><a href="#Tokitsukaze-and-Rescue" class="headerlink" title="Tokitsukaze and Rescue"></a>Tokitsukaze and Rescue</h1><a id="more"></a>
<p>Princess CJB has lived almost her entire life in the isolated town of Ertona, where CJB uses her unique ability to recognize where crystals of materials are buried. By way of a fateful encounter, CJB learns of the Alchemy Exam and decides to take her first step into the outside world, setting off on a grand journey to become a certified alchemist and discover the mysteries that life has to offer!</p>
<p>In order to take part in the Alchemy Exam, CJB goes to the Reisenberg town without any partners. But the kingdom Adalet is unbelievably enormous so that there are many hidden risks. Claris, a powerful evil magician, wants to monopolize CJB for the extraordinary beauty of her. Due to the power limitation of CJB, she can’t escape from Claris without any assistance. The alchemist Tokitsukaze has heard this savage act and wants to rescue the princess CJB.</p>
<p>There are n cities numbered from 1 to n in the kingdom Adalet. Because of the excellent transportation, there is exactly a two-way road between any two cites. Tokitsukaze lives in city 1. The Magician Claris lives in city n. Since the exam will be held soon, Tokitsukaze wants to rescue CJB as fast as possible, so she will choose the shortest path to reach city n.</p>
<p>Claris has also heard this news and is afraid of being punished, so he decides to slow Tokitsukaze down by making an explosion on k roads he chose and causing these roads to lose their capability of two-way transportation, since it can pave the way for having enough time to prepare his powerful magic against Tokitsukaze.</p>
<p>Tokitsukaze knows some roads will be destroyed and can immediately recognize where they are, but she has no approach to prevent this explosion, so she chooses just to move along the shortest path after Claris completes his explosion.</p>
<p>Now Claris wants to know, after finishing his explosion, what the longest possible length is of the shortest path from city 1 to city n.</p>
<hr>
<h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>There are several test cases.</p>
<p>The first line contains an integer T (1≤T≤100), denoting the number of test cases. Then follow all the test cases.</p>
<p>For each test case, the first line contains two integers n and k (3≤n≤50,1≤k≤min(n−2,5)), denoting the number of cities and the number of roads being exploded, respectively.</p>
<p>The next n(n−1)2 lines describe all the roads, where each line contains three integers u, v and w (1≤u,v≤n,u≠v,1≤w≤104), representing a two-way road of length w between city u and city v. It is guaranteed that for every two cities, there exists exactly one road whose length is randomly distributed between 1 and 104.</p>
<h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each case, output in one line an integer, denoting the longest possible length of the shortest path after the explosion.</p>
<h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><blockquote>
3<br/>
5 1<br/>
1 2 2990<br/>
1 3 2414<br/>
1 4 4018<br/>
1 5 6216<br/>
2 3 9140<br/>
2 4 4169<br/>
2 5 550<br/>
3 4 6618<br/>
3 5 3206<br/>
4 5 105<br/>
5 2<br/>
1 2 2990<br/>
1 3 2414<br/>
1 4 4018<br/>
1 5 6216<br/>
2 3 9140<br/>
2 4 4169<br/>
2 5 550<br/>
3 4 6618<br/>
3 5 3206<br/>
4 5 105<br/>
5 3<br/>
1 2 2990<br/>
1 3 2414<br/>
1 4 4018<br/>
1 5 6216<br/>
2 3 9140<br/>
2 4 4169<br/>
2 5 550<br/>
3 4 6618<br/>
3 5 3206<br/>
4 5 105<br/>
</blockquote>

<h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><blockquote>
4123<br/>
5620<br/>
6216
</blockquote>



<h2 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">55</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[N], lose[N][N];</span><br><span class="line"><span class="comment">//n是顶点数，k是要删除的边数</span></span><br><span class="line"><span class="keyword">int</span> n, k, u, v, w, ans;</span><br><span class="line"><span class="keyword">int</span> mp[N][N], path[N], dis[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(path, <span class="number">0</span>, <span class="keyword">sizeof</span>(path));          <span class="comment">//存dijkstra的路径</span></span><br><span class="line">    <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));          <span class="comment">//存最短路的路径大小</span></span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line"></span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>, path[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d=INF, f=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; d)&#123;</span><br><span class="line">                d = dis[j];</span><br><span class="line">                f = j;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">//f记录从i点出发最短的是f点</span></span><br><span class="line">        vis[f]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;=n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[f]+mp[f][j] &lt; dis[j] &amp;&amp; !lose[f][j])&#123;</span><br><span class="line">                dis[j]=dis[f]+mp[f][j];                 <span class="comment">//变更j的路径，从f到j</span></span><br><span class="line">                path[j]=f;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    dijkstra();</span><br><span class="line">    <span class="keyword">if</span>(x==k+<span class="number">1</span>)&#123;                  <span class="comment">//删k边，跑k+1次dijkstra</span></span><br><span class="line">        ans=max(ans, dis[n]);    <span class="comment">//dis[n]是最短路的长度，求最大值</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pre 的作用是只枚举截断最短路的边！！</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n, pre=n; i; i=path[i])&#123;      <span class="comment">//path[i]存的是i的上一个节点</span></span><br><span class="line">        lose[i][pre]=lose[pre][i]=<span class="literal">true</span>;    <span class="comment">//枚举删除的边</span></span><br><span class="line">        dfs(x+<span class="number">1</span>);</span><br><span class="line">        lose[i][pre]=lose[pre][i]=<span class="literal">false</span>;    <span class="comment">//回溯</span></span><br><span class="line">        pre=i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(mp, INF, <span class="keyword">sizeof</span>(mp));            <span class="comment">//初始化图的距离</span></span><br><span class="line">    <span class="built_in">memset</span>(lose, <span class="number">0</span>, <span class="keyword">sizeof</span>(lose));          <span class="comment">//初始化删的边</span></span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//图中无“圈”</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        mp[i][i]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n*(n<span class="number">-1</span>)/<span class="number">2</span>; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        mp[u][v]=mp[v][u]=w;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//提高cin cout效率</span></span><br><span class="line">    ios::sync_with_stdio(<span class="literal">false</span>);</span><br><span class="line">    <span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>), <span class="built_in">cout</span>.tie(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h2>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>最短路</tag>
        <tag>dfs</tag>
      </tags>
  </entry>
  <entry>
    <title>八皇后算法</title>
    <url>/2020/08/04/%E5%85%AB%E7%9A%87%E5%90%8E%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<h1 id="转载至-点击查看原博客"><a href="#转载至-点击查看原博客" class="headerlink" title="转载至 点击查看原博客"></a>转载至 <a href="https://blog.csdn.net/qq_42552533/article/details/86684045" title="原博客链接">点击查看原博客</a></h1></blockquote>
<a id="more"></a>

<p><strong>为了理解“递归回溯”的思想，我们不妨先将4位皇后打入冷宫，留下剩下的4位安排进4x4的格子中且不能互相打架，有多少种安排方法呢？现在我们把第一个皇后放在第一个格子，被涂黑的地方是不能放皇后的:</strong><br/></p>
<p><img src="https://img-blog.csdnimg.cn/20190128225239203.png#pic_center"></p>
<p><strong>第二行的皇后只能放在第三格或第四格，比如我们放在第三格:</strong> <br/></p>
<p><img src="https://img-blog.csdnimg.cn/20190128225341886.png#pic_center" alt="放第二个皇后"></p>
<p><strong>这样一来前面两位皇后已经把第三行全部锁死了，第三位皇后无论放在第三行的哪里都难逃被吃掉的厄运。于是在第一个皇后位于第一格，第二个皇后位于第三格的情况下此问题无解。所以我们只能返回上一步，来给2号皇后换个位置:</strong><br/></p>
<p><img src="https://img-blog.csdnimg.cn/20190128225441858.png#pic_center" alt="给第二个皇后换位置"></p>
<p><strong>此时，第三个皇后只有一个位置可选。当第三个皇后占据第三行蓝色空位时，第四行皇后无路可走，于是发生错误，则返回上层调整3号皇后，而3号皇后也别无可去，继续返回上层调整2号皇后，而2号皇后已然无路可去，则再继续返回上层调整1号皇后，于是1号皇后往后移一格位置如下，再继续往下安排:</strong><br/><br><img src="https://img-blog.csdnimg.cn/20190128225624834.png#pic_center"></p>
<h2 id="核心代码："><a href="#核心代码：" class="headerlink" title="核心代码："></a>核心代码：</h2><span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueen</span><span class="params">( <span class="keyword">int</span> row )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">if</span>( row&gt;<span class="number">7</span> )                       <span class="comment">//如果遍历完八行都找到放置皇后的位置则打印</span></span><br><span class="line">    &#123;</span><br><span class="line">        Print();                       <span class="comment">//打印八皇后的解 </span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( col=<span class="number">0</span>; col &lt; <span class="number">8</span>; col++ )        <span class="comment">//回溯，递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( notDanger( row, col ) )    <span class="comment">// 判断是否危险</span></span><br><span class="line">        &#123;</span><br><span class="line">            chess[row][col]=<span class="number">1</span>;</span><br><span class="line">            EightQueen(row+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            chess[row][col]=<span class="number">0</span>;           <span class="comment">//清零，以免回溯时出现脏数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</span>

<h2 id="我们来重点看一下这段代码："><a href="#我们来重点看一下这段代码：" class="headerlink" title="我们来重点看一下这段代码："></a>我们来重点看一下这段代码：</h2><blockquote>
第一次进来，row=0，意思是要在第一行摆皇后，只要传进来的row参数不是8，表明还没出结果，就都不会走if里面的return，那么就进入到for循环里面，col从0开始，即第一列。此时第一行第一列肯定合乎要求（即notDanger方法肯定通过），能放下皇后，因为还没有任何其他皇后来干扰。<br/>
关键是notDanger方法通过了之后，在if里面又会调用一下自己（即递归），row加了1，表示摆第二行的皇后了。
第二行的皇后在走for循环的时候，分两种情况，第一种情况：for循环没走到头时就有通过notDanger方法的了，那么这样就顺理成章地往下走再调用一下自己（即再往下递归），row再加1（即摆第三行的皇后了，以此类推）。第二种情况：for循环走到头了都没有通过notDanger方法的，说明第二行根本一个皇后都摆不了，也触发不了递归，下面的第三行等等后面的就更不用提了，此时控制第一行皇后位置的for循环col加1，即第一行的皇后往后移一格，即摆在第一行第二列的位置上，然后再往下走，重复上述逻辑。<br/>
注意，一定要添加清零的代码，它只有在皇后摆不下去的时候会执行清0的动作（避免脏数据干扰），如果皇后摆放很顺利的话从头到尾是不会走这个请0的动作的，因为已经提前走if里面的return方法结束了。<br/>
总之，这段核心代码很绕，原理一定要想通，想个十几二十遍差不多就能理解其中的原理了，递归回溯的思想也就不言而喻了。八皇后问题一共有92种情况
</blockquote>


<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><span>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> chess[<span class="number">8</span>][<span class="number">8</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">notDanger</span><span class="params">( <span class="keyword">int</span> row, <span class="keyword">int</span> col )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,k;</span><br><span class="line">    <span class="comment">// 判断列方向</span></span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i &lt; <span class="number">8</span>; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( chess[i][col]==<span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断左对角线 </span></span><br><span class="line">    <span class="keyword">for</span>( i=row, k=col; i&gt;=<span class="number">0</span> &amp;&amp; k&gt;=<span class="number">0</span>; i--, k-- )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(chess[i][k]==<span class="number">1</span>  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断右对角线 </span></span><br><span class="line">    <span class="keyword">for</span>( i=row, k=col; i&gt;=<span class="number">0</span> &amp;&amp; k&lt;<span class="number">8</span>; i--, k++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(chess[i][k]==<span class="number">1</span>  )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span>          <span class="comment">//打印结果 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第 %d 种\n&quot;</span>, count+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>( row=<span class="number">0</span>; row &lt; <span class="number">8</span>; row++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( col=<span class="number">0</span>; col&lt; <span class="number">8</span>; col++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(chess[row][col]==<span class="number">1</span>)        <span class="comment">//皇后用‘0’表示</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;0 &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;# &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EightQueen</span><span class="params">( <span class="keyword">int</span> row )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">if</span>( row&gt;<span class="number">7</span> )                       <span class="comment">//如果遍历完八行都找到放置皇后的位置则打印</span></span><br><span class="line">    &#123;</span><br><span class="line">        Print();                       <span class="comment">//打印八皇后的解 </span></span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( col=<span class="number">0</span>; col &lt; <span class="number">8</span>; col++ )        <span class="comment">//回溯，递归</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( notDanger( row, col ) )    <span class="comment">// 判断是否危险</span></span><br><span class="line">        &#123;</span><br><span class="line">            chess[row][col]=<span class="number">1</span>;</span><br><span class="line">            EightQueen(row+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">            chess[row][col]=<span class="number">0</span>;           <span class="comment">//清零，以免回溯时出现脏数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    EightQueen(<span class="number">0</span>);        </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总共有 %d 种解决方法!\n\n&quot;</span>, count);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</span>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>八皇后</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>区间DP</title>
    <url>/2020/08/07/%E5%8C%BA%E9%97%B4DP/</url>
    <content><![CDATA[<a id="more"></a>

<p>#</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>

</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>

</blockquote>


<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 205</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="comment">//dp[l][r]表示这个区间内的最长的regular brackets</span></span><br><span class="line"><span class="keyword">int</span> dp[MAX][MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">char</span> a, <span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a == <span class="string">&#x27;(&#x27;</span> &amp;&amp; b == <span class="string">&#x27;)&#x27;</span>) || (a == <span class="string">&#x27;[&#x27;</span> &amp;&amp; b == <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp,<span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= size; len++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>, r = l+len<span class="number">-1</span>; r &lt;= size; l++, r++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(judge(str[l],str[r]))</span><br><span class="line">                dp[l][r] = dp[l+<span class="number">1</span>][r<span class="number">-1</span>]+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//断点枚举是不管匹不匹配都要做的</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line">                dp[l][r] = max(dp[l][r], dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">1</span>][size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s &amp;&amp; s!=<span class="string">&quot;end&quot;</span>)&#123;</span><br><span class="line">        str = <span class="string">&quot; &quot;</span>;</span><br><span class="line">        str += s;</span><br><span class="line">        <span class="keyword">int</span> size = str.size();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dfs(size<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>完全背包(持续更新)</title>
    <url>/2020/08/06/%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<h1 id="完全背包模板"><a href="#完全背包模板" class="headerlink" title="完全背包模板"></a>完全背包模板</h1><a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T是背包容量，M是总数</span></span><br><span class="line"><span class="keyword">int</span> T,M;</span><br><span class="line"><span class="keyword">int</span> w[<span class="number">10005</span>],v[<span class="number">10005</span>];</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">1000005</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>一维，与01背包一维的区别就是这个是正序</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">complete_pack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w[i]; j &lt;= T; j++)</span><br><span class="line">            f[j] = max(f[j - w[i]] + v[i], f[j]);</span><br><span class="line">    <span class="keyword">return</span> f[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二维版本，完全背包数据大，二维数组dp可能会炸</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">complete_pack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//画表过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= T; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; w[i])&#123;</span><br><span class="line">                dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//这里的序号也要改</span></span><br><span class="line">                <span class="keyword">if</span>(dp[i<span class="number">-1</span>][j] &gt; dp[i][j-w[i]]+v[i])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">//与01背包不同，可以重复装</span></span><br><span class="line">                    dp[i][j] = dp[i][j-w[i]]+v[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[M][T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<p>主函数随便写写</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T&gt;&gt;M;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= M; i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;complete_pack()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>多重背包之HDU2844</title>
    <url>/2020/08/06/%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<a id="more"></a>
<h1 id="Coins"><a href="#Coins" class="headerlink" title="Coins"></a>Coins</h1><p>Whuacmers use coins.They have coins of value A1,A2,A3…An Silverland dollar. One day Hibix opened purse and found there were some coins. He decided to buy a very nice watch in a nearby shop. He wanted to pay the exact price(without change) and he known the price would not more than m.But he didn’t know the exact price of the watch.</p>
<p>You are to write a program which reads n,m,A1,A2,A3…An and C1,C2,C3…Cn corresponding to the number of Tony’s coins of value A1,A2,A3…An then calculate how many prices(form 1 to m) Tony can pay use these coins.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>The input contains several test cases. The first line of each test case contains two integers n(1 ≤ n ≤ 100),m(m ≤ 100000).The second line contains 2n integers, denoting A1,A2,A3…An,C1,C2,C3…Cn (1 ≤ Ai ≤ 100000,1 ≤ Ci ≤ 1000). The last test case is followed by two zeros.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each test case output the answer on a single line.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
3 10            <br/>
1 2 4 2 1 1     <br/>
2 5             <br/>
1 4 2 1         <br/>
0 0             <br/>
</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
8   <br/>
4   <br/>
</blockquote>


<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> f[MAX];</span><br><span class="line"><span class="keyword">int</span> value[MAX],number[MAX];<span class="comment">//分别存的是物品的价值，每一个的重量以及数量</span></span><br><span class="line"><span class="keyword">int</span> bag;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zero_one_pack</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> v)</span><span class="comment">//01背包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bag; j &gt;= w; j--)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = max(f[j],f[j-w]+v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">complete_pack</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> v)</span><span class="comment">//完全背包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = w; j &lt;= bag; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        f[j] = max(f[j],f[j-w]+v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h2><p><strong>二进制转换，拆分成多个物品</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiple_pack</span><span class="params">(<span class="keyword">int</span> w,<span class="keyword">int</span> v,<span class="keyword">int</span> num)</span><span class="comment">//多重背包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bag&lt;num*w)<span class="comment">//如果总容量比这个物品的容量要小，那么这个物品可以直到取完，相当于完全背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        complete_pack(w,v);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//否则就将多重背包转化为01背包</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; num)</span><br><span class="line">        &#123;</span><br><span class="line">            zero_one_pack(k*w,k*v);</span><br><span class="line">            num = num-k;</span><br><span class="line">            k = <span class="number">2</span>*k;<span class="comment">//这里采用二进制思想</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num)</span><br><span class="line">            zero_one_pack(num*w,num*v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>最外层的组数循环可以放在多重背包调用函数外面</strong></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n&gt;&gt;bag &amp;&amp; !(n==<span class="number">0</span>&amp;&amp;bag==<span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;value[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//WA的点！！！</span></span><br><span class="line">        <span class="comment">//fill的第二参数是迭代器的end(),不能到达的部分，所以要f+bag+1</span></span><br><span class="line">        fill(f,f+bag+<span class="number">1</span>,-INF);</span><br><span class="line">        f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            multiple_pack(value[i],value[i],number[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bag; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i] &gt; <span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>背包</category>
      </categories>
      <tags>
        <tag>DP</tag>
        <tag>背包</tag>
      </tags>
  </entry>
  <entry>
    <title>基础数论</title>
    <url>/2020/08/12/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="快速幂"><a href="#快速幂" class="headerlink" title="快速幂"></a>快速幂</h1><p>求a^b</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>, base = a;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span> != <span class="number">0</span>)</span><br><span class="line">            ans *= base;</span><br><span class="line">            </span><br><span class="line">        base *= base;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="快速幂取余"><a href="#快速幂取余" class="headerlink" title="快速幂取余"></a>快速幂取余</h2><p>取模运算的乘法规则</p>
<blockquote>
<p><strong>(a × b) % p = ((a % p) × (b % p)) % p</strong></p>
</blockquote>
<h3 id="HDU2035"><a href="#HDU2035" class="headerlink" title="HDU2035"></a><a href="https://vjudge.net/problem/HDU-2035">HDU2035</a></h3><p>只需要用到最后三位，但如果算出结果再模1000，计算量非常大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickPow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>, base = a, p = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="comment">//二进制的与，用来替换b%2==1</span></span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) </span><br><span class="line">            ans = ans * base % p;</span><br><span class="line">        base = base * base % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="质数筛"><a href="#质数筛" class="headerlink" title="质数筛"></a>质数筛</h1><hr>
<h1 id="同余方程"><a href="#同余方程" class="headerlink" title="同余方程"></a>同余方程</h1><ul>
<li>来点模运算法则<blockquote>
a ≡ b(mod p) 读作a关于b模p同余 即 a%p == b%p<br/>
a + b ≡ (a%p + b%p)(mod p)<br/>
a - b ≡ (a%p - b%p)(mod p)<br/>
a × b ≡ (a%p × b%p)(mod p)<br/>
</blockquote>


</li>
</ul>
<h2 id="辗转相除法-gcd"><a href="#辗转相除法-gcd" class="headerlink" title="辗转相除法 gcd"></a>辗转相除法 gcd</h2><p><strong>求r最大使得a%r==0 &amp;&amp; b%r==0</strong><br>辗转相除法的复杂度是O(logn),小于更相减损术O(n)</p>
<blockquote>
<p>定理1: gcd(a,b) * lcm(a<em>b) = a</em>b<br/><br>定理2: 若r = gcd(a, b), 且a = m<em>r, b = n</em>r, 则有n和m互质</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b==<span class="number">0</span>? a : gcd(b, a%b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="欧几里得拓展-exgcd"><a href="#欧几里得拓展-exgcd" class="headerlink" title="欧几里得拓展 exgcd"></a>欧几里得拓展 exgcd</h2><blockquote>
<p>贝祖定理  给予二整数 a 与 b, 必存在有整数x与y使得ax + by = gcd(a,b)</p>
</blockquote>
<p>扩展欧几里得算法是欧几里得算法（又叫辗转相除法）的扩展。除了计算a、b两个整数的最大公约数d，此算法还能找到整数x、y（其中一个很可能是负数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b) &#123; </span><br><span class="line">        d = a; x = <span class="number">1</span>; y = <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        gcd(b, a%b, y, x, d); </span><br><span class="line">        y -= x*(a/b); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h2><p>为了实现模运算的除法，引入逆元–数论倒数 $a^{-1}$ <br/><br>$a × a^{-1} ≡ 1 (mod p)$<br/><br>$a^{-1} ≠ \frac{1}{a}$<br/><br>定义 inv(a) 为逆元<br/><br>有<strong>a ÷ b ≡ (a%p × inv(b)%p)(mod p)</strong></p>
<h3 id="费马小定理求逆元-已经把输入的a模了p！！！"><a href="#费马小定理求逆元-已经把输入的a模了p！！！" class="headerlink" title="费马小定理求逆元(已经把输入的a模了p！！！)"></a>费马小定理求逆元(已经把输入的a模了p！！！)</h3><blockquote>
<p>费马小定理 若p是质数，那么有：$a^{p-1} ≡ 1$ (mod p)<br>则有 inv(a) = $a^{p-2}(mod p)$, 使用快速幂求解</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">quickPow</span><span class="params">(ll a,ll b, ll p)</span></span>&#123;<span class="comment">//a^b%p  </span></span><br><span class="line">    ll res = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">while</span>(b)&#123;    </span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) </span><br><span class="line">            res = (res*a)%p;     </span><br><span class="line">        a = (a*a)%p;    </span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">getInv</span><span class="params">(ll a,ll p)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> quickPow(a,p<span class="number">-2</span>,p); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">answer = (a%p*getInv(b, mod))%mod</span><br></pre></td></tr></table></figure>

<h3 id="拓展欧几里得求逆元-已经把输入的a模了p！！！"><a href="#拓展欧几里得求逆元-已经把输入的a模了p！！！" class="headerlink" title="拓展欧几里得求逆元(已经把输入的a模了p！！！)"></a>拓展欧几里得求逆元(已经把输入的a模了p！！！)</h3><p>对于方程$a × x + b × y = 1$ 当a,b互质时有解<br/><br>x是a关于b的逆元，y是b关于a的逆元<br/><br>有 $a × x = 1$ (mod b)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exGcd</span><span class="params">(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(!b)&#123;</span><br><span class="line">        d = a, x = <span class="number">1</span>, y =<span class="number">0</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">else</span>&#123;    </span><br><span class="line">        exGcd(b,a%b,y,x,d);    </span><br><span class="line">        y -= x*(a/b);  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">ll <span class="title">getInv</span><span class="params">(ll a, ll p)</span></span>&#123;  </span><br><span class="line">    ll d, x, y;  </span><br><span class="line">    exGcd(a,p,x,y,d);  </span><br><span class="line">    <span class="keyword">return</span> d == <span class="number">1</span>?(x%p+p)%p : <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">answer = (a%p*getInv(b, mod))%mod</span><br></pre></td></tr></table></figure>


<h3 id="线性递归求逆元"><a href="#线性递归求逆元" class="headerlink" title="线性递归求逆元"></a>线性递归求逆元</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll INV[MAX];</span><br><span class="line"><span class="function">ll <span class="title">getInv</span><span class="params">(ll a,ll p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> INV[a] = a==<span class="number">1</span>?:(p-p/a)*getInv(p%a,p)%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>快速幂</tag>
        <tag>质数筛</tag>
        <tag>GCD</tag>
        <tag>同余方程</tag>
        <tag>逆元</tag>
        <tag>中国剩余定理</tag>
      </tags>
  </entry>
  <entry>
    <title>最短路算法总结</title>
    <url>/2020/08/11/%E6%9C%80%E7%9F%AD%E8%B7%AF%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><h1 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h1><ul>
<li>Floyd动态规划本质分析 <a href="https://www.cnblogs.com/chenying99/p/3932877.html">点击进入参考博客</a></li>
</ul>
<h2 id="POJ3660-闭包传递例题"><a href="#POJ3660-闭包传递例题" class="headerlink" title="POJ3660 闭包传递例题"></a><a href="https://vjudge.net/problem/POJ-3660">POJ3660</a> 闭包传递例题</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1050</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m, ans;</span><br><span class="line"><span class="keyword">int</span> g[MAX][MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">floyd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">                <span class="comment">//把间接击败的也标记</span></span><br><span class="line">                <span class="keyword">if</span>(g[i][k] &amp;&amp; g[k][j])</span><br><span class="line">                    g[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; m; t++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        g[a][b] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    floyd();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++, cnt++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//两个点未被注明关系</span></span><br><span class="line">            <span class="keyword">if</span>(g[i][j] == <span class="number">0</span> &amp;&amp; g[j][i] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;n) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<h1 id="dijkstra算法–不能跑负权边和最长路"><a href="#dijkstra算法–不能跑负权边和最长路" class="headerlink" title="dijkstra算法–不能跑负权边和最长路"></a>dijkstra算法–不能跑负权边和最长路</h1><h2 id="朴素写法-O-n-2-e"><a href="#朴素写法-O-n-2-e" class="headerlink" title="朴素写法 O(n^2+e)"></a>朴素写法 O(n^2+e)</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mindis = INF;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        <span class="comment">//找到离源点最近的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; mindis)&#123;</span><br><span class="line">                mindis = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入已选集合</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[u][v] &lt; INF)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">                    dis[v] = dis[u] + g[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[e];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="堆优化-O-n-elogn"><a href="#堆优化-O-n-elogn" class="headerlink" title="堆优化 O(n+elogn)"></a>堆优化 O(n+elogn)</h2><p>堆优化，顾名思义，就是用堆进行优化。我们通过学习朴素DIJ算法，明白DIJ算法的实现需要从头到尾扫一遍点找出最小的点然后进行松弛。这个扫描操作就是坑害朴素DIJ算法时间复杂度的罪魁祸首。所以我们使用小根堆，用优先队列来维护这个“最小的点”。从而大大减少DIJ算法的时间复杂度</p>
<p><strong>用到了链式前向星的建图</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[MAX],head[MAX];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> next,to,w;</span><br><span class="line">&#125;edge[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//first位存距离，second位存编号，形成点的编号-权值 映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; P;</span><br><span class="line"><span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        head[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(d, INF, <span class="keyword">sizeof</span>(d));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//greater是小根堆, front是最小的距离的点</span></span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;P,<span class="built_in">vector</span>&lt;P&gt;,greater&lt;P&gt; &gt; que;</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    que.push(P(<span class="number">0</span>,s));</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        P p = que.top();</span><br><span class="line">        que.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//u是当前点的序号，以下操作和朴素写法其实一样</span></span><br><span class="line">        <span class="keyword">int</span> u = p.second;</span><br><span class="line">        <span class="comment">//如果经过一个过渡点到达该点的距离小于起点直接到达该点的距离，那么已经没有必要再松弛</span></span><br><span class="line">        <span class="keyword">if</span>(d[u] &lt; p.first)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u]; i != <span class="number">-1</span>; i=edge[i].next)&#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].w + d[u] &lt; d[edge[i].to])&#123;</span><br><span class="line">                d[edge[i].to] = edge[i].w + d[u];</span><br><span class="line">                que.push(P( d[edge[i].to], edge[i].to ));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="POJ1797"><a href="#POJ1797" class="headerlink" title="POJ1797"></a><a href="https://vjudge.net/problem/POJ-1797">POJ1797</a></h2><p>dijkstra的变式，求最小载重量里的最大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 1050</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> g[MAX][MAX], vis[MAX], weight[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        weight[i] = g[<span class="number">1</span>][i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> maxweight = -INF;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; weight[j] &gt; maxweight)&#123;</span><br><span class="line">                maxweight = weight[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v] &amp;&amp; weight[v] &lt; min(weight[u], g[u][v]))&#123;</span><br><span class="line">                weight[v] = min(weight[u], g[u][v]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> weight[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;T;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = <span class="number">1</span>; t &lt;= T; t++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(g, -INF, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(weight, INF , <span class="keyword">sizeof</span>(weight));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            g[a][b] = c;</span><br><span class="line">            g[b][a] = g[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Scenario #%d:\n%d\n\n&quot;</span>, t, dijkstra());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">3</span></span><br><span class="line"><span class="comment">3 3</span></span><br><span class="line"><span class="comment">1 2 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">2 3 5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5 5</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 3 1</span></span><br><span class="line"><span class="comment">3 4 2</span></span><br><span class="line"><span class="comment">2 4 5</span></span><br><span class="line"><span class="comment">4 5 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">6 9</span></span><br><span class="line"><span class="comment">1 4 4</span></span><br><span class="line"><span class="comment">4 5 2</span></span><br><span class="line"><span class="comment">5 6 2</span></span><br><span class="line"><span class="comment">1 6 10</span></span><br><span class="line"><span class="comment">1 2 0</span></span><br><span class="line"><span class="comment">2 3 3</span></span><br><span class="line"><span class="comment">2 5 6</span></span><br><span class="line"><span class="comment">2 6 8</span></span><br><span class="line"><span class="comment">3 5 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="HDU2544"><a href="#HDU2544" class="headerlink" title="HDU2544"></a><a href="https://vjudge.net/problem/HDU-2544">HDU2544</a></h2><p>用二维数组g建图的朴素模板题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 105</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> s, e;</span><br><span class="line"><span class="keyword">int</span> g[MAX][MAX], vis[MAX], dis[MAX];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> mindis = INF;</span><br><span class="line">        <span class="keyword">int</span> u;</span><br><span class="line">        <span class="comment">//找到离源点最近的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; mindis)&#123;</span><br><span class="line">                mindis = dis[j];</span><br><span class="line">                u = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入已选集合</span></span><br><span class="line">        vis[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= n; v++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[u][v] &lt; INF);&#123;</span><br><span class="line">                <span class="keyword">if</span>(dis[v] &gt; dis[u] + g[u][v])</span><br><span class="line">                    dis[v] = dis[u] + g[u][v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis[e];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m) &amp;&amp; !(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>))&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="built_in">memset</span>(g, INF, <span class="keyword">sizeof</span>(g));</span><br><span class="line">        <span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">        <span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line">        s = <span class="number">1</span>, e = n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            g[a][b] = min(g[a][b], c);</span><br><span class="line">            g[b][a] = g[a][b];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;dijkstra()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>dijkstra</tag>
        <tag>最短路</tag>
        <tag>Floyd</tag>
        <tag>belle-man</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集ufs模板总结</title>
    <url>/2020/08/08/%E5%B9%B6%E6%9F%A5%E9%9B%86ufs%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>
<p><strong>并查集这个东西很方便“集合”的查询、合并、树的路径压缩</strong><br><strong>但是它并不方便从树根向叶的查询，路径压缩也会破坏树的结构</strong></p>
<ul>
<li>用数组ufs[i]表示每个节点i的根是谁，根的根是自己</li>
<li>用数组sum[i]表示当节点i作为根时，整个(子)树上的节点个数</li>
<li>数组set自定义的..记录下有多少个集合</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 30010</span></span><br><span class="line"><span class="keyword">int</span> sum[MAXN];    <span class="comment">//集合总数</span></span><br><span class="line"><span class="keyword">int</span> ufs[MAXN];    <span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[MAXN];</span><br></pre></td></tr></table></figure>

<h1 id="基础函数"><a href="#基础函数" class="headerlink" title="基础函数"></a>基础函数</h1><ul>
<li>把每个节点的根先设置为自己，而且每个节点所在子树的节点数先设置为1</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span>    <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">        sum[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>没找到根节点,就递归把a连到a的根节点上</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetRoot</span><span class="params">(<span class="keyword">int</span> a)</span>    <span class="comment">//获得a的根节点。路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ufs[a]!=a)&#123;    </span><br><span class="line">        ufs[a] = GetRoot(ufs[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ufs[a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>两根相等辣没事，两根不等就把<strong>两根</strong>连在一起</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span>    <span class="comment">//合并a和b的集合</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = GetRoot(a);</span><br><span class="line">    <span class="keyword">int</span> y = GetRoot(b);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">        ufs[y] = x;</span><br><span class="line">        sum[x] += sum[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不重要的main函数</li>
<li>有多个cases在main中别忘了预处理之类的</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T, m, n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;T);</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="keyword">sizeof</span>(sum));</span><br><span class="line">        <span class="built_in">memset</span>(ufs, <span class="number">0</span>, <span class="keyword">sizeof</span>(ufs));</span><br><span class="line">        <span class="built_in">memset</span>(<span class="built_in">set</span>, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="built_in">set</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title>最/次小生成树模板总结</title>
    <url>/2020/08/10/%E6%9C%80-%E6%AC%A1%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<a id="more"></a>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 20000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">//建立并查集</span></span><br><span class="line"><span class="keyword">int</span> ufs[MAX];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ufs[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Getroot</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ufs[a]!=a)&#123;</span><br><span class="line">        ufs[a] = Getroot(ufs[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ufs[a];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = Getroot(a);</span><br><span class="line">    <span class="keyword">int</span> y = Getroot(b);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">        ufs[y] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">line</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, e;</span><br><span class="line">    <span class="keyword">int</span> cost;</span><br><span class="line"></span><br><span class="line">&#125;road[MAX];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(line a, line b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.cost &lt; b.cost;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="built_in">queue</span>&lt;line&gt; que;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())</span><br><span class="line">        que.pop();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Getroot(road[i].s) != Getroot(road[i].e))&#123;</span><br><span class="line">            Union(road[i].s, road[i].e);</span><br><span class="line">            ans += road[i].cost;</span><br><span class="line">            que.push(road[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">second</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">while</span>(!que.empty())&#123;</span><br><span class="line">        line p = que.front();</span><br><span class="line">        que.pop();</span><br><span class="line">        Init(n);</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>,len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(road[i].s == p.s &amp;&amp; road[i].e == p.e &amp;&amp; road[i].cost == p.cost) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(Getroot(road[i].s) != Getroot(road[i].e))&#123;</span><br><span class="line">                Union(road[i].s, road[i].e);</span><br><span class="line">                cur += road[i].cost;</span><br><span class="line">                ++len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(len == n) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == n)</span><br><span class="line">            ans = min(ans,cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(road,<span class="number">0</span>,<span class="keyword">sizeof</span>(road));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">        Init(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;road[i].s, &amp;road[i].e, &amp;road[i].cost);</span><br><span class="line"></span><br><span class="line">        sort(road, road+m, cmp);</span><br><span class="line">        <span class="keyword">int</span> ans1 = kruskal();</span><br><span class="line">        <span class="keyword">int</span> ans2 = second();</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ans1&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;ans2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
  </entry>
  <entry>
    <title>线段树模板总结</title>
    <url>/2020/08/05/%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A8%A1%E6%9D%BF%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="ppt代码-使用心得"><a href="#ppt代码-使用心得" class="headerlink" title="ppt代码+使用心得"></a>ppt代码+使用心得</h1><p>感觉线段树的题目数组要开大一点，毕竟访问叶子节点的“子节点”的时候访问的都是越过N的</p>
<a id="more"></a>

<h2 id="单点修改-amp-区间查询"><a href="#单点修改-amp-区间查询" class="headerlink" title="单点修改&amp;区间查询"></a>单点修改&amp;区间查询</h2><p>单点修改是不碰到叶子节点不止步的，与区间节点相反，<strong>需要在修改递归完之后回溯，本区间节点加上两个儿子区间的sum</strong><br>区间查询相对后面两种情况的查询函数会更简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    rt[i].sum = rt[i * <span class="number">2</span>].sum</span><br><span class="line">              + rt[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i表示当前节点位置，l指左区间，r指右区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt[i].l = l;</span><br><span class="line">    rt[i].r = r;</span><br><span class="line">    <span class="comment">//到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        rt[i].sum = val[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(i*<span class="number">2</span>, l, mid);</span><br><span class="line">    build(i*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> target, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].r&lt;target || rt[i].l&gt;target)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l == rt[i].r) &#123;</span><br><span class="line">        rt[i].sum += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    modify(i*<span class="number">2</span>,target,k);</span><br><span class="line">    modify(i*<span class="number">2</span>+<span class="number">1</span>,target,k);</span><br><span class="line">    <span class="comment">//找到后回溯，需要重新计算该点值，把叶子节点的值加到区间节点上，防止深度过大</span></span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].r &lt;  l || rt[i].l &gt;  r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].r &lt;= r &amp;&amp; rt[i].l &gt;= l)</span><br><span class="line">        <span class="keyword">return</span> rt[i].sum;</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r)+query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="区间修改-amp-单点查询"><a href="#区间修改-amp-单点查询" class="headerlink" title="区间修改&amp;单点查询"></a>区间修改&amp;单点查询</h2><p>这种情况，区间修改需要被修改的k值(染色值)，并没有被push_down，而是根据题目的输入，<strong>分布在各个区间（父节点）</strong>，止步与<strong>满足修改区间的最小区间</strong><br>也就是说要执行单点查询的query函数时，要从root(的儿子)开始累加rt[i].sum</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    rt[i].sum = rt[i * <span class="number">2</span>].sum</span><br><span class="line">              + rt[i*<span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i表示当前节点位置，l指左区间，r指右区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt[i].l = l;</span><br><span class="line">    rt[i].r = r;</span><br><span class="line">    <span class="comment">//到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        rt[i].sum = val[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(i*<span class="number">2</span>, l, mid);</span><br><span class="line">    build(i*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//k是 题目需求的整个区间的需要修改的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt; r || rt[i].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//区间修改， 到了满足l-r的最大区间就会停止</span></span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt;= l &amp;&amp; rt[i].r &lt;= r)&#123;</span><br><span class="line">        rt[i].sum += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//去找其他和l-r相交的区间</span></span><br><span class="line">    modify(<span class="number">2</span>*i,l,r,k);</span><br><span class="line">    modify(<span class="number">2</span>*i+<span class="number">1</span>,l,r,k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt; target || rt[i].r &lt; target)  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = rt[i].sum;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l == rt[i].r)  <span class="keyword">return</span> rt[i].sum;</span><br><span class="line">    ans += (query(i*<span class="number">2</span>,target) + query(i*<span class="number">2</span>+<span class="number">1</span>,target));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="区间修改-amp-区间查询"><a href="#区间修改-amp-区间查询" class="headerlink" title="区间修改&amp;区间查询"></a>区间修改&amp;区间查询</h2><p>区间修改是不会把<strong>修改值k(区间修改值)**推到每个叶子的，<br/><br>而是止步于“</strong>满足修改区间的最小区间<strong>”<br>比如给[1,3]染色，相当于给[1,2]和[3]染色(**叶子2的节点数是5，而区间[1,2]的节点数是3</strong>)<br><strong>查询[2,4]区间的时候，叶子[2]的染色值是0！！</strong><br>所以引入lazy延迟标签，在查询的时候向下推<br>lazy标签是给该区间每一个点染上色，所以计算一个区间的sum值，要先把本区间的lazy值push_down<br><strong>本区间sum值 = 左儿子区间sum + 左儿子lazy + 右儿子sum + 右儿子lazy</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线段树的节点用node实现</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum,lazy;</span><br><span class="line">&#125;rt[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//val用来储存题目给的序列的值</span></span><br><span class="line"><span class="keyword">int</span> val[MAX];</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算当前节点lazy</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (rt[i].r - rt[i].l) * rt[i].lazy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//push_up用于计算当前节点的和/最大值/最小值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    rt[i].sum = rt[i * <span class="number">2</span>].sum + calc(i*<span class="number">2</span>)</span><br><span class="line">              + rt[i*<span class="number">2</span>+<span class="number">1</span>].sum + calc(i*<span class="number">2</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i表示当前节点位置，l指左区间，r指右区间</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt[i].l = l;</span><br><span class="line">    rt[i].r = r;</span><br><span class="line">    <span class="comment">//到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(l == r)&#123;</span><br><span class="line">        <span class="comment">//别把rt[i].sum赋值错了</span></span><br><span class="line">        rt[i].sum = val[r];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(i*<span class="number">2</span>, l, mid);</span><br><span class="line">    build(i*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    rt[<span class="number">2</span> * i].lazy = rt[i].lazy;</span><br><span class="line">    rt[<span class="number">2</span>*i+<span class="number">1</span>].lazy = rt[i].lazy;</span><br><span class="line">    <span class="comment">//lazy下放后清空当前lazy</span></span><br><span class="line">    rt[i].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//k是 题目需求的整个区间的需要修改的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modify</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt; r || rt[i].r &lt; l) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//区间修改， 到了满足l-r的最大区间就会停止</span></span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt;= l &amp;&amp; rt[i].r &lt;= r)&#123;</span><br><span class="line">        rt[i].lazy += k;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(i);</span><br><span class="line">    <span class="comment">//去找其他和l-r相交的区间</span></span><br><span class="line">    modify(<span class="number">2</span>*i,l,r,k);</span><br><span class="line">    modify(<span class="number">2</span>*i+<span class="number">1</span>,l,r,k);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt; r || rt[i].r &lt; l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l &gt;= l &amp;&amp; rt[i].r &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">return</span> rt[i].sum + calc(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把堆积在节点的lazy下放</span></span><br><span class="line">    push_down(i);</span><br><span class="line">    push_up(i);</span><br><span class="line">    <span class="keyword">return</span> query(<span class="number">2</span>*i,l,r) + query(<span class="number">2</span>*i+<span class="number">1</span>,l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>在求区间最值而不是sum的时候，最小值查询函数在没找到的时候<br><strong>一定要把返回值设置为MAX之类的大数</strong><br>否则在return min(xx,xx)的时候会把0返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_max</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt_max[i].r &lt;  l || rt_max[i].l &gt;  r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(rt_max[i].r &lt;= r &amp;&amp; rt_max[i].l &gt;= l)</span><br><span class="line">        <span class="keyword">return</span> rt_max[i].sum;</span><br><span class="line">    <span class="keyword">return</span> max(query_max(<span class="number">2</span>*i,l,r),query_max(<span class="number">2</span>*i+<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query_min</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt_min[i].r &lt;  l || rt_min[i].l &gt;  r)</span><br><span class="line">        <span class="keyword">return</span> MAX;</span><br><span class="line">    <span class="keyword">if</span>(rt_min[i].r &lt;= r &amp;&amp; rt_min[i].l &gt;= l)</span><br><span class="line">        <span class="keyword">return</span> rt_min[i].sum;</span><br><span class="line">    <span class="keyword">return</span> min(query_min(<span class="number">2</span>*i,l,r),query_min(<span class="number">2</span>*i+<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HDU2795-Billboard"><a href="#HDU2795-Billboard" class="headerlink" title="HDU2795 Billboard"></a>HDU2795 Billboard</h1><p>At the entrance to the university, there is a huge rectangular billboard of size h*w (h is its height and w is its width). The board is the place where all possible announcements are posted: nearest programming competitions, changes in the dining room menu, and other important information.</p>
<p>On September 1, the billboard was empty. One by one, the announcements started being put on the billboard.</p>
<p>Each announcement is a stripe of paper of unit height. More specifically, the i-th announcement is a rectangle of size 1 * wi.</p>
<p>When someone puts a new announcement on the billboard, she would always choose the topmost possible position for the announcement. Among all possible topmost positions she would always choose the leftmost one.</p>
<p>If there is no valid location for a new announcement, it is not put on the billboard (that’s why some programming contests have no participants from this university).</p>
<p>Given the sizes of the billboard and the announcements, your task is to find the numbers of rows in which the announcements are placed.</p>
<h2 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h2><p>There are multiple cases (no more than 40 cases).</p>
<p>The first line of the input file contains three integer numbers, h, w, and n (1 &lt;= h,w &lt;= 10^9; 1 &lt;= n &lt;= 200,000) - the dimensions of the billboard and the number of announcements.</p>
<p>Each of the next n lines contains an integer number wi (1 &lt;= wi &lt;= 10^9) - the width of i-th announcement.</p>
<h2 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h2><p>For each announcement (in the order they are given in the input file) output one number - the number of the row in which this announcement is placed. Rows are numbered from 1 to h, starting with the top row. If an announcement can’t be put on the billboard, output “-1” for this announcement.</p>
<h2 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h2><blockquote>
3 5 5<br/>
2   <br/>
4   <br/>
3   <br/>
3   <br/>
3   <br/>
</blockquote>

<h2 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h2><blockquote>
1   <br/>
2   <br/>
1   <br/>
3   <br/>
-1  <br/>
</blockquote>

<h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 2001000</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r,sum;</span><br><span class="line">&#125;rt[MAX];</span><br><span class="line"><span class="keyword">int</span> h,w,n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    rt[i].sum = rt[i * <span class="number">2</span>].sum&gt;rt[i*<span class="number">2</span>+<span class="number">1</span>].sum?rt[i * <span class="number">2</span>].sum:rt[i * <span class="number">2</span>+<span class="number">1</span>].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    rt[i].l = l;</span><br><span class="line">    rt[i].r = r;</span><br><span class="line">    <span class="keyword">if</span>(l == r) &#123;</span><br><span class="line">        rt[i].sum = w;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    build(i*<span class="number">2</span>, l, mid);</span><br><span class="line">    build(i*<span class="number">2</span>+<span class="number">1</span>, mid+<span class="number">1</span>, r);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="重点解说"><a href="#重点解说" class="headerlink" title="重点解说"></a>重点解说</h2><p>这道题其实是把板子的行和列交换了(转置)，行当作线段树的val数组, 列用来储存，当作val[i]的值<br>这样是线段树的变种，单点修改单点查询，就不需要modify函数，直接在query函数内修改<br>然后要注意题目说的优先级，有空位时优先放置左上方向的位置(行列交换也是)，<br><strong>在query函数中就要优先搜索左儿子</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(rt[i].l == rt[i].r)&#123;</span><br><span class="line">        rt[i].sum -= op;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,rt[i].r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里是重点，题意是如果左边有空就先上左边</span></span><br><span class="line">    <span class="comment">//要用if else,如果在开头判断if(rt[i].sum &lt; op)</span></span><br><span class="line">    <span class="comment">//就两边都有空的时候两边都去,错误</span></span><br><span class="line">    <span class="keyword">if</span>(rt[i*<span class="number">2</span>].sum&gt;=op) query(i*<span class="number">2</span>,op);</span><br><span class="line">    <span class="keyword">else</span> query(i*<span class="number">2</span>+<span class="number">1</span>,op);</span><br><span class="line">    push_up(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后题目给的h范围很大，但不是从1开始数的，所以可以大胆把h设置为n<br>n为放置的公告数，也就是说从1开始编号h就不会大于n<br>判定整个板子满了的条件放在main里了，也提醒了在query函数里面就要push_up</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;h,&amp;w,&amp;n)!=EOF) &#123;</span><br><span class="line">        <span class="comment">//h 深度不能太大，n为放置的公告数，也就是说从1开始编号h就不会大于n</span></span><br><span class="line">        h = h&gt;n?n:h;</span><br><span class="line">        build(<span class="number">1</span>, <span class="number">1</span>, h);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> op;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">            <span class="comment">//直接判断根节点，也就是整个树的最大值</span></span><br><span class="line">            <span class="keyword">if</span> (rt[<span class="number">1</span>].sum &gt;= op) query(<span class="number">1</span>, op);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>知乎: 如何看待Trump正式封杀tiktok和微信</title>
    <url>/2020/08/08/%E7%9F%A5%E4%B9%8E-%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85Trump%E6%AD%A3%E5%BC%8F%E5%B0%81%E6%9D%80tiktok%E5%92%8C%E5%BE%AE%E4%BF%A1/</url>
    <content><![CDATA[<a id="more"></a>

<p>转自知乎用户 <a href="https://www.zhihu.com/people/dong-liang-85">猴子老湿</a></p>
<blockquote>

<p>我在法学院的时候，一个偏左的法理学教授意味深长地对我们说了一句话——<strong>去政治化本身就是一种政治</strong><br/><br>到今天，结合字节跳动等企业在美国的受挫，我算是稍微了解了一点这句话的含义。现代资本主义国家，一直是主张国际秩序和投资环境去政治化的。而且，他们标榜自身就是一个去政治化发展起来的典范。<br/><br>他们把自己标榜为政治与经济相分离，市场经济不受政治约束自我循环，社会秩序可以脱离政治自我维系的一种理想国家模型。一切对经济的干预和社会革命都是对自然市场秩序的破坏，都会受到他们的谴责。在去政治化的基础上，发展起来了<strong>互联网自由、普世价值、科技无国界</strong>等口号。<br/><br>但是当你真的信了这些口号，你就上当了。因为这些口号是去政治化的产物，而去政治化本身就是一种政治。去政治化的政治目的是让你放松对西方资本主义国家和资本家的警惕，让发展中国家在面对发达国家资本和文化的侵袭时，采取听之任之、不抵抗的政策。<strong>如果你抵抗了，那么你就是政治干预，你就不民主、不法治。</strong><br/><br>这正如某互联网大佬说“在该奋斗的年龄不要选择安逸”一样，这句话看似强调奋斗的价值，实际上是为了更多地榨取码农的剩余价值。但是，最最麻烦的地方在于，你还不能很好地反驳奋斗观这种表面正确的价值。<br/><br>正如发展中国家不能很好地反驳民主、法治、自由一样，在西方去政治化的阴谋面前，很多国家无力招架。<br/><br>这是去政治化非常高明的地方。但是正如上文所说，去政治化不代表政治不存在，只不过宣扬去政治化的国家，把政治獠牙小心地收了起来，装作和善的样子。当你相信了去政治化的口号以后，你按照去政治化的方式去美国等西方国家投资，威胁到他们的经济利益和国家利益时，你就会感受到，他们会把去政治化那一套收了起来，而把政治这匹恶狼放出来（这批饿狼可能还会被去政治化洗脑的人称之为法治）。<br/><br><strong>一家按照去政治化要求构建的企业，即将被自70年代后期开始潜伏的去政治化阴谋咬死，这实在算不得什么阴谋。只能说算是被忽悠瘸了的代价。</strong></p>
</blockquote>]]></content>
  </entry>
  <entry>
    <title>链式前向星</title>
    <url>/2020/08/11/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/</url>
    <content><![CDATA[<a id="more"></a>

<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><strong>其中edge[i].to表示第i条边的终点,edge[i].next表示与第i条边同起点的逆序遍历的下一条边(也就是储存的顺-序)的存储位置,edge[i].w为边权值.</strong><br/><br><strong>另外还有一个数组head[],它是用来表示以i为起点的第一条边存储的位置,实际上你会发现这里的第一条边存储的位置其实</strong><br/><br><strong>在以i为起点的所有边的最后输入的那个编号.</strong></p>
<blockquote>
输入：

<p>1 2</p>
<p>2 3</p>
<p>3 4</p>
<p>1 3</p>
<p>4 1</p>
<p>1 5</p>
<p>4 5</p>
<p>储存过程：（注意head数组）</p>
<p>edge[0].to = 2;     edge[0].next = -1;      head[1] = 0;</p>
<p>edge[1].to = 3;     edge[1].next = -1;      head[2] = 1;</p>
<p>edge[2].to = 4;     edge[2].next = -1;      head[3] = 2;</p>
<p>edge[3].to = 3;     edge[3].next = 0;       head[1] = 3;</p>
<p>edge[4].to = 1;     edge[4].next = -1;      head[4] = 4;</p>
<p>edge[5].to = 5;     edge[5].next = 3;       head[1] = 5;</p>
<p>edge[6].to = 5;     edge[6].next = 4;       head[4] = 6;</p>
</blockquote>


<h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">1005</span>;<span class="comment">//点数最大值</span></span><br><span class="line"><span class="keyword">int</span> n, m, cnt;<span class="comment">//n个点，m条边</span></span><br><span class="line"><span class="keyword">int</span> head[maxn];<span class="comment">//head[i],表示以i为起点的(逆序)第一条边在边集数组的位置（编号）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>必须的结构体<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, w, next;<span class="comment">//终点，边权，同起点的上一条边的编号</span></span><br><span class="line">&#125;edge[maxn];<span class="comment">//边集</span></span><br></pre></td></tr></table></figure></li>
<li>加边函数，将head[u]赋值给next<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) head[i] = <span class="number">-1</span>;</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意遍历怎么写，<strong>初始用head数组进入，之后不断取next就可以遍历</strong><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">int</span> u, v, w;</span><br><span class="line">    init();<span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//输入m条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        add_edge(u, v, w);<span class="comment">//加边</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        加双向边</span></span><br><span class="line"><span class="comment">        add_edge(u, v, w);</span></span><br><span class="line"><span class="comment">        add_edge(v, u, w);</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//起点i不一定要用for，可能是题目给的</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">5 7</span></span><br><span class="line"><span class="comment">1 2 1</span></span><br><span class="line"><span class="comment">2 3 2</span></span><br><span class="line"><span class="comment">3 4 3</span></span><br><span class="line"><span class="comment">1 3 4</span></span><br><span class="line"><span class="comment">4 1 5</span></span><br><span class="line"><span class="comment">1 5 6</span></span><br><span class="line"><span class="comment">4 5 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>链表</tag>
        <tag>链式前向星</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建教程</title>
    <url>/2020/08/03/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<h3 id="转载至-点击跳转至原文"><a href="#转载至-点击跳转至原文" class="headerlink" title="转载至 点击跳转至原文 "></a>转载至 <a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md" title="原文链接">点击跳转至原文</a> <br/></h3></blockquote>
<h1 id="hexo-theme-matery"><a href="#hexo-theme-matery" class="headerlink" title="hexo-theme-matery"></a>hexo-theme-matery</h1><a id="more"></a>

<p><a href="http://hits.dwyl.io/blinkfox/hexo-theme-matery"><img src="http://hits.dwyl.io/blinkfox/hexo-theme-matery.svg" alt="HitCount"></a> <a href="https://gitter.im/hexo-theme-matery/Lobby?utm_source=badge"><img src="https://img.shields.io/gitter/room/blinkfox/hexo-theme-matery.svg" alt="Gitter"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/issues"><img src="https://img.shields.io/github/issues/blinkfox/hexo-theme-matery.svg" alt="GitHub issues"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/blob/master/LICENSE"><img src="https://img.shields.io/github/license/blinkfox/hexo-theme-matery.svg" alt="GitHub license"></a> <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master"><img src="https://img.shields.io/badge/downloads-master-green.svg" alt="Download"></a> <a href="http://hexo.io/"><img src="https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg" alt="Hexo Version"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/network"><img src="https://img.shields.io/github/forks/blinkfox/hexo-theme-matery.svg" alt="GitHub forks"></a> <a href="https://github.com/blinkfox/hexo-theme-matery/stargazers"><img src="https://img.shields.io/github/stars/blinkfox/hexo-theme-matery.svg" alt="GitHub stars"></a></p>
<p><a href="README.md">🇺🇸English Document</a> | <a href="http://blinkfox.com/">国内访问示例 (http://blinkfox.com)</a> | <a href="https://blinkfox.github.io/">Github 部署演示示例 (https://blinkfox.github.io)</a> | QQ 交流群1（已满）: <a href="https://jq.qq.com/?_wv=1027&k=5zMDYHT"><code>926552981</code></a> | QQ 交流群2（推荐）: <a href="https://jq.qq.com/?_wv=1027&k=53q2Ayp"><code>971887688</code></a></p>
<blockquote>
<p>这是一个采用 <code>Material Design</code> 和响应式设计的 Hexo 博客主题。</p>
</blockquote>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>简单漂亮，文章内容美观易读</li>
<li><a href="https://material.io/">Material Design</a> 设计</li>
<li>响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现</li>
<li>首页轮播文章及每天动态切换 <code>Banner</code> 图片</li>
<li>瀑布流式的博客文章列表（文章无特色图片时会有 <code>24</code> 张漂亮的图片代替）</li>
<li>时间轴式的归档页</li>
<li><strong>词云</strong>的标签页和<strong>雷达图</strong>的分类页</li>
<li>丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）</li>
<li>可自定义的数据的友情链接页面</li>
<li>支持文章置顶和文章打赏</li>
<li>支持 <code>MathJax</code></li>
<li><code>TOC</code> 目录</li>
<li>可设置复制文章内容时追加版权信息</li>
<li>可设置阅读文章时做密码验证</li>
<li><a href="https://gitalk.github.io/">Gitalk</a>、<a href="https://imsun.github.io/gitment/">Gitment</a>、<a href="https://valine.js.org/">Valine</a> 和 <a href="https://disqus.com/">Disqus</a> 评论模块（推荐使用 <code>Gitalk</code>）</li>
<li>集成了<a href="http://busuanzi.ibruce.info/">不蒜子统计</a>、谷歌分析（<code>Google Analytics</code>）和文章字数统计等功能</li>
<li>支持在首页的音乐播放和视频播放功能</li>
<li>支持<code>emoji</code>表情，用<code>markdown emoji</code>语法书写直接生成对应的能<strong>跳跃</strong>的表情。</li>
<li>支持 <a href="http://www.daovoice.io/">DaoVoice</a>、<a href="https://www.tidio.com/">Tidio</a> 在线聊天功能。</li>
</ul>
<h2 id="贡献者"><a href="#贡献者" class="headerlink" title="贡献者"></a>贡献者</h2><p>感谢下面列出的贡献者，没有他们，hexo-theme-matery 不会这么完美。</p>
<ul>
<li><a href="https://github.com/HarborZeng">@HarborZeng</a></li>
<li><a href="https://github.com/shw2018">@shw2018</a></li>
<li><a href="https://github.com/L1cardo">@L1cardo</a></li>
<li><a href="https://github.com/Five-great">@Five-great</a></li>
</ul>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>当你看到这里的时候，应该已经有一个自己的 <a href="https://hexo.io/zh-cn/">Hexo</a> 博客了。如果还没有的话，不妨使用 Hexo 和 <a href="https://www.appinn.com/markdown/">Markdown</a> 来写博客和文章。</p>
<p>点击 <a href="https://codeload.github.com/blinkfox/hexo-theme-matery/zip/master">这里</a> 下载 <code>master</code> 分支的最新稳定版的代码，解压缩后，将 <code>hexo-theme-matery</code> 的文件夹复制到你 Hexo 的 <code>themes</code> 文件夹中即可。</p>
<p>当然你也可以在你的 <code>themes</code> 文件夹下使用 <code>Git clone</code> 命令来下载:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/blinkfox/hexo-theme-matery.git</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>修改 Hexo 根目录下的 <code>_config.yml</code> 的  <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p>
<h4 id="config-yml-文件的其它修改建议"><a href="#config-yml-文件的其它修改建议" class="headerlink" title="_config.yml 文件的其它修改建议:"></a><code>_config.yml</code> 文件的其它修改建议:</h4><ul>
<li>请修改 <code>_config.yml</code> 的 <code>url</code> 的值为你的网站主 <code>URL</code>（如：<code>http://xxx.github.io</code>）。</li>
<li>建议修改两个 <code>per_page</code> 的分页条数值为 <code>6</code> 的倍数，如：<code>12</code>、<code>18</code> 等，这样文章列表在各个屏幕下都能较好的显示。</li>
<li>如果你是中文用户，则建议修改 <code>language</code> 的值为 <code>zh-CN</code>。</li>
</ul>
<h3 id="新建分类-categories-页"><a href="#新建分类-categories-页" class="headerlink" title="新建分类 categories 页"></a>新建分类 categories 页</h3><p><code>categories</code> 页是用来展示所有分类的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>categories/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure>

<p>编辑你刚刚新建的页面文件 <code>/source/categories/index.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">categories</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-30 17:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="新建标签-tags-页"><a href="#新建标签-tags-页" class="headerlink" title="新建标签 tags 页"></a>新建标签 tags 页</h3><p><code>tags</code> 页是用来展示所有标签的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>tags/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;tags&quot;</span></span><br></pre></td></tr></table></figure>

<p>编辑你刚刚新建的页面文件 <code>/source/tags/index.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-30 18:23:38</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="新建关于我-about-页"><a href="#新建关于我-about-页" class="headerlink" title="新建关于我 about 页"></a>新建关于我 about 页</h3><p><code>about</code> 页是用来展示<strong>关于我和我的博客</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>about/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;about&quot;</span></span><br></pre></td></tr></table></figure>

<p>编辑你刚刚新建的页面文件 <code>/source/about/index.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">about</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-30 17:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;about&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="新建留言板-contact-页（可选的）"><a href="#新建留言板-contact-页（可选的）" class="headerlink" title="新建留言板 contact 页（可选的）"></a>新建留言板 contact 页（可选的）</h3><p><code>contact</code> 页是用来展示<strong>留言板</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>contact/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;contact&quot;</span></span><br></pre></td></tr></table></figure>

<p>编辑你刚刚新建的页面文件 <code>/source/contact/index.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">contact</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-30 17:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;contact&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;contact&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：本留言板功能依赖于第三方评论系统，请<strong>激活</strong>你的评论系统才有效果。并且在主题的 <code>_config.yml</code> 文件中，第 <code>19</code> 至 <code>21</code> 行的“<strong>菜单</strong>”配置，取消关于留言板的注释即可。</p>
</blockquote>
<h3 id="新建友情链接-friends-页（可选的）"><a href="#新建友情链接-friends-页（可选的）" class="headerlink" title="新建友情链接 friends 页（可选的）"></a>新建友情链接 friends 页（可选的）</h3><p><code>friends</code> 页是用来展示<strong>友情链接</strong>信息的页面，如果在你的博客 <code>source</code> 目录下还没有 <code>friends/index.md</code> 文件，那么你就需要新建一个，命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page <span class="string">&quot;friends&quot;</span></span><br></pre></td></tr></table></figure>

<p>编辑你刚刚新建的页面文件 <code>/source/friends/index.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">friends</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-12-12 21:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;friends&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;friends&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<p>同时，在你的博客 <code>source</code> 目录下新建 <code>_data</code> 目录，在 <code>_data</code> 目录中新建 <code>friends.json</code> 文件，文件内容如下所示：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;http://image.luokangyuan.com/1_qq_27922023.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;码酱&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;introduction&quot;</span>: <span class="string">&quot;我不是大佬，只是在追寻大佬的脚步&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;http://luokangyuan.com/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;前去学习&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;http://image.luokangyuan.com/4027734.jpeg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;闪烁之狐&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;introduction&quot;</span>: <span class="string">&quot;编程界大佬，技术牛，人还特别好，不懂的都可以请教大佬&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://blinkfox.github.io/&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;前去学习&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">    <span class="attr">&quot;avatar&quot;</span>: <span class="string">&quot;http://image.luokangyuan.com/avatar.jpg&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ja_rome&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;introduction&quot;</span>: <span class="string">&quot;平凡的脚步也可以走出伟大的行程&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;url&quot;</span>: <span class="string">&quot;https://me.csdn.net/jlh912008548&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;前去学习&quot;</span></span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="新建-404-页"><a href="#新建-404-页" class="headerlink" title="新建 404 页"></a>新建 404 页</h3><p>如果在你的博客 <code>source</code> 目录下还没有 <code>404.md</code> 文件，那么你就需要新建一个</p>
<p>编辑你刚刚新建的页面文件 <code>/source/404.md</code>，至少需要以下内容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="number">404</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-30 17:25:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="attr">layout:</span> <span class="string">&quot;404&quot;</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">&quot;Oops～，我崩溃了！找不到你想要的页面 :(&quot;</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="菜单导航配置"><a href="#菜单导航配置" class="headerlink" title="菜单导航配置"></a>菜单导航配置</h3><h4 id="配置基本菜单导航的名称、路径url和图标icon"><a href="#配置基本菜单导航的名称、路径url和图标icon" class="headerlink" title="配置基本菜单导航的名称、路径url和图标icon."></a>配置基本菜单导航的名称、路径url和图标icon.</h4><p>1.菜单导航名称可以是中文也可以是英文(如：<code>Index</code>或<code>主页</code>)<br>2.图标icon 可以在<a href="https://fontawesome.com/icons">Font Awesome</a> 中查找   </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Index:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Tags:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/tags</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">Categories:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/categories</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">  <span class="attr">Archives:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/archives</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">About:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/about</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-user-circle</span></span><br><span class="line">  <span class="attr">Friends:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/friends</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-address-book</span></span><br></pre></td></tr></table></figure>

<h4 id="二级菜单配置方法"><a href="#二级菜单配置方法" class="headerlink" title="二级菜单配置方法"></a>二级菜单配置方法</h4><p>如果你需要二级菜单则可以在原基本菜单导航的基础上如下操作<br>1.在需要添加二级菜单的一级菜单下添加<code>children</code>关键字(如:<code>About</code>菜单下添加<code>children</code>)<br>2.在<code>children</code>下创建二级菜单的 名称name,路径url和图标icon.<br>3.注意每个二级菜单模块前要加 <code>-</code>.<br>4.注意缩进格式  </p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">Index:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="attr">Tags:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/tags</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">Categories:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/categories</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-bookmark</span></span><br><span class="line">  <span class="attr">Archives:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/archives</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="attr">About:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/about</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-user-circle-o</span></span><br><span class="line">  <span class="attr">Friends:</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">/friends</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-address-book</span></span><br><span class="line">  <span class="attr">Medias:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-list</span></span><br><span class="line">    <span class="attr">children:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Musics</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/musics</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-music</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Movies</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/movies</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-film</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Books</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/books</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-book</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Galleries</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">/galleries</span></span><br><span class="line">        <span class="attr">icon:</span> <span class="string">fas</span> <span class="string">fa-image</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后就可以在文章中对应位置看到你用<code>emoji</code>语法写的表情了。</p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -S hexo-prism-plugin</span><br></pre></td></tr></table></figure>

<p>然后，修改 Hexo 根目录下 <code>_config.yml</code> 文件中 <code>highlight.enable</code> 的值为 <code>false</code>，并新增 <code>prism</code> 插件相关的配置，主要配置如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="attr">prism_plugin:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">&#x27;preprocess&#x27;</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">&#x27;tomorrow&#x27;</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">custom_css:</span></span><br></pre></td></tr></table></figure>

<h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>本主题中还使用到了 <a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 的 Hexo 插件来做内容搜索，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br></pre></td></tr></table></figure>

<h3 id="中文链接转拼音（建议安装）"><a href="#中文链接转拼音（建议安装）" class="headerlink" title="中文链接转拼音（建议安装）"></a>中文链接转拼音（建议安装）</h3><p>如果你的文章名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用 <a href="https://github.com/viko16/hexo-permalink-pinyin">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p>
<p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i hexo-permalink-pinyin --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink_pinyin:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">separator:</span> <span class="string">&#x27;-&#x27;</span> <span class="comment"># default: &#x27;-&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p>
</blockquote>
<h3 id="文章字数统计插件（建议安装）"><a href="#文章字数统计插件（建议安装）" class="headerlink" title="文章字数统计插件（建议安装）"></a>文章字数统计插件（建议安装）</h3><p>如果你想要在文章中显示文章字数、阅读时长信息，可以安装 <a href="https://github.com/willin/hexo-wordcount">hexo-wordcount</a>插件。</p>
<p>安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i --save hexo-wordcount</span><br></pre></td></tr></table></figure>

<p>然后只需在本主题下的 <code>_config.yml</code> 文件中，将各个文章字数相关的配置激活即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">postInfo:</span></span><br><span class="line">  <span class="attr">date:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">update:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">wordCount:</span> <span class="literal">false</span> <span class="comment"># 设置文章字数统计为 true.</span></span><br><span class="line">  <span class="attr">totalCount:</span> <span class="literal">false</span> <span class="comment"># 设置站点文章总字数统计为 true.</span></span><br><span class="line">  <span class="attr">min2read:</span> <span class="literal">false</span> <span class="comment"># 阅读时长.</span></span><br><span class="line">  <span class="attr">readCount:</span> <span class="literal">false</span> <span class="comment"># 阅读次数.</span></span><br></pre></td></tr></table></figure>

<h3 id="添加emoji表情支持（可选的）"><a href="#添加emoji表情支持（可选的）" class="headerlink" title="添加emoji表情支持（可选的）"></a>添加emoji表情支持（可选的）</h3><p>本主题新增了对<code>emoji</code>表情的支持，使用到了 <a href="https://npm.taobao.org/package/hexo-filter-github-emojis">hexo-filter-github-emojis</a> 的 Hexo 插件来支持 <code>emoji</code>表情的生成，把对应的<code>markdown emoji</code>语法（<code>::</code>,例如：<code>:smile:</code>）转变成会跳跃的<code>emoji</code>表情，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-filter-github-emojis --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">githubEmojis:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">className:</span> <span class="string">github-emoji</span></span><br><span class="line">  <span class="attr">inject:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">styles:</span></span><br><span class="line">  <span class="attr">customEmojis:</span></span><br></pre></td></tr></table></figure>

<h3 id="添加-RSS-订阅支持（可选的）"><a href="#添加-RSS-订阅支持（可选的）" class="headerlink" title="添加 RSS 订阅支持（可选的）"></a>添加 RSS 订阅支持（可选的）</h3><p>本主题中还使用到了 <a href="https://github.com/hexojs/hexo-generator-feed">hexo-generator-feed</a> 的 Hexo 插件来做 <code>RSS</code>，安装命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>

<p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br><span class="line">  <span class="attr">hub:</span></span><br><span class="line">  <span class="attr">content:</span></span><br><span class="line">  <span class="attr">content_limit:</span> <span class="number">140</span></span><br><span class="line">  <span class="attr">content_limit_delim:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>

<p>执行 <code>hexo clean &amp;&amp; hexo g</code> 重新生成博客文件，然后在 <code>public</code> 文件夹中即可看到 <code>atom.xml</code> 文件，说明你已经安装成功了。</p>
<h3 id="添加-DaoVoice-在线聊天功能（可选的）"><a href="#添加-DaoVoice-在线聊天功能（可选的）" class="headerlink" title="添加 DaoVoice 在线聊天功能（可选的）"></a>添加 <a href="http://www.daovoice.io/">DaoVoice</a> 在线聊天功能（可选的）</h3><p>前往 <a href="http://www.daovoice.io/">DaoVoice</a> 官网注册并且获取 <code>app_id</code>，并将 <code>app_id</code> 填入主题的 <code>_config.yml</code> 文件中。</p>
<h3 id="添加-Tidio-在线聊天功能（可选的）"><a href="#添加-Tidio-在线聊天功能（可选的）" class="headerlink" title="添加 Tidio 在线聊天功能（可选的）"></a>添加 <a href="https://www.tidio.com/">Tidio</a> 在线聊天功能（可选的）</h3><p>前往 <a href="https://www.tidio.com/">Tidio</a> 官网注册并且获取 <code>Public Key</code>，并将 <code>Public Key</code> 填入主题的 <code>_config.yml</code> 文件中。</p>
<h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h3><p>页脚信息可能需要做定制化修改，而且它不便于做成配置信息，所以可能需要你自己去再修改和加工。修改的地方在主题文件的 <code>/layout/_partial/footer.ejs</code> 文件中，包括站点、使用的主题、访问量等。</p>
<h3 id="修改社交链接"><a href="#修改社交链接" class="headerlink" title="修改社交链接"></a>修改社交链接</h3><p>在主题的 <code>_config.yml</code> 文件中，默认支持 <code>QQ</code>、<code>GitHub</code> 和邮箱等的配置，你可以在主题文件的 <code>/layout/_partial/social-link.ejs</code> 文件中，新增、修改你需要的社交链接地址，增加链接可参考如下代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">if</span> (<span class="attr">theme.socialLink.github</span>) &#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&lt;%= theme.socialLink.github %&gt;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;tooltipped&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">data-tooltip</span>=<span class="string">&quot;访问我的GitHub&quot;</span> <span class="attr">data-position</span>=<span class="string">&quot;top&quot;</span> <span class="attr">data-delay</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fab fa-github&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> &#125; %&gt;</span></span><br></pre></td></tr></table></figure>

<p>其中，社交图标（如：<code>fa-github</code>）你可以在 <a href="https://fontawesome.com/icons">Font Awesome</a> 中搜索找到。以下是常用社交图标的标识，供你参考：</p>
<ul>
<li>Facebook: <code>fab fa-facebook</code></li>
<li>Twitter: <code>fab fa-twitter</code></li>
<li>Google-plus: <code>fab fa-google-plus</code></li>
<li>Linkedin: <code>fab fa-linkedin</code></li>
<li>Tumblr: <code>fab fa-tumblr</code></li>
<li>Medium: <code>fab fa-medium</code></li>
<li>Slack: <code>fab fa-slack</code></li>
<li>Sina Weibo: <code>fab fa-weibo</code></li>
<li>Wechat: <code>fab fa-weixin</code></li>
<li>QQ: <code>fab fa-qq</code></li>
<li>Zhihu: <code>fab fa-zhihu</code></li>
</ul>
<blockquote>
<p><strong>注意</strong>: 本主题中使用的 <code>Font Awesome</code> 版本为 <code>5.11.0</code>。</p>
</blockquote>
<h3 id="修改打赏的二维码图片"><a href="#修改打赏的二维码图片" class="headerlink" title="修改打赏的二维码图片"></a>修改打赏的二维码图片</h3><p>在主题文件的 <code>source/medias/reward</code> 文件中，你可以替换成你的的微信和支付宝的打赏二维码图片。</p>
<h3 id="配置音乐播放器（可选的）"><a href="#配置音乐播放器（可选的）" class="headerlink" title="配置音乐播放器（可选的）"></a>配置音乐播放器（可选的）</h3><p>要支持音乐播放，在主题的 <code>_config.yml</code> 配置文件中激活music配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否在首页显示音乐</span></span><br><span class="line"><span class="attr">music:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span>             <span class="comment"># 非吸底模式有效</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">show:</span> <span class="string">听听音乐</span></span><br><span class="line">  <span class="attr">server:</span> <span class="string">netease</span>   <span class="comment"># require music platform: netease, tencent, kugou, xiami, baidu</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">playlist</span>    <span class="comment"># require song, playlist, album, search, artist</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">503838841</span>     <span class="comment"># require song id / playlist id / album id / search keyword</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span>      <span class="comment"># 开启吸底模式</span></span><br><span class="line">  <span class="attr">autoplay:</span> <span class="literal">false</span>   <span class="comment"># 是否自动播放</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">&#x27;#42b983&#x27;</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="string">&#x27;all&#x27;</span>       <span class="comment"># 音频循环播放, 可选值: &#x27;all&#x27;, &#x27;one&#x27;, &#x27;none&#x27;</span></span><br><span class="line">  <span class="attr">order:</span> <span class="string">&#x27;random&#x27;</span>   <span class="comment"># 音频循环顺序, 可选值: &#x27;list&#x27;, &#x27;random&#x27;</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="string">&#x27;auto&#x27;</span>   <span class="comment"># 预加载，可选值: &#x27;none&#x27;, &#x27;metadata&#x27;, &#x27;auto&#x27;</span></span><br><span class="line">  <span class="attr">volume:</span> <span class="number">0.7</span>       <span class="comment"># 默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效</span></span><br><span class="line">  <span class="attr">listFolded:</span> <span class="literal">true</span>  <span class="comment"># 列表默认折叠</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>server</code>可选<code>netease</code>（网易云音乐），<code>tencent</code>（QQ音乐），<code>kugou</code>（酷狗音乐），<code>xiami</code>（虾米音乐），</p>
<p><code>baidu</code>（百度音乐）。</p>
<p><code>type</code>可选<code>song</code>（歌曲），<code>playlist</code>（歌单），<code>album</code>（专辑），<code>search</code>（搜索关键字），<code>artist</code>（歌手）</p>
<p><code>id</code>获取方法示例: 浏览器打开网易云音乐，点击我喜欢的音乐歌单，浏览器地址栏后面会有一串数字，<code>playlist</code>的<code>id</code></p>
<p>即为这串数字。</p>
</blockquote>
<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p>
<table>
<thead>
<tr>
<th>配置选项</th>
<th>默认值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>title</td>
<td><code>Markdown</code> 的文件标题</td>
<td>文章标题，强烈建议填写此选项</td>
</tr>
<tr>
<td>date</td>
<td>文件创建时的日期时间</td>
<td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td>
</tr>
<tr>
<td>author</td>
<td>根 <code>_config.yml</code> 中的 <code>author</code></td>
<td>文章作者</td>
</tr>
<tr>
<td>img</td>
<td><code>featureImages</code> 中的某个值</td>
<td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td>
</tr>
<tr>
<td>top</td>
<td><code>true</code></td>
<td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td>
</tr>
<tr>
<td>cover</td>
<td><code>false</code></td>
<td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td>
</tr>
<tr>
<td>coverImg</td>
<td>无</td>
<td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td>
</tr>
<tr>
<td>password</td>
<td>无</td>
<td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td>
</tr>
<tr>
<td>toc</td>
<td><code>true</code></td>
<td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td>
</tr>
<tr>
<td>mathjax</td>
<td><code>false</code></td>
<td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td>
</tr>
<tr>
<td>summary</td>
<td>无</td>
<td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td>
</tr>
<tr>
<td>categories</td>
<td>无</td>
<td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td>
</tr>
<tr>
<td>tags</td>
<td>无</td>
<td>文章标签，一篇文章可以多个标签</td>
</tr>
<tr>
<td>keywords</td>
<td>文章标题</td>
<td>文章关键字，SEO 时需要</td>
</tr>
<tr>
<td>reprintPolicy</td>
<td>cc_by</td>
<td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>:</p>
<ol>
<li>如果 <code>img</code> 属性不填写的话，文章特色图会根据文章标题的 <code>hashcode</code> 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图<strong>各有特色</strong>。</li>
<li><code>date</code> 的值尽量保证每篇文章是唯一的，因为本主题中 <code>Gitalk</code> 和 <code>Gitment</code> 识别 <code>id</code> 是通过 <code>date</code> 的值来作为唯一标识的。</li>
<li>如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 <code>_config.yml</code> 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：<a href="http://tool.oschina.net/encrypt?type=2">开源中国在线工具</a>、<a href="http://encode.chahuo.com/">chahuo</a>、<a href="http://tool.chinaz.com/tools/hash.aspx">站长工具</a>。</li>
<li>您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则</li>
</ol>
</blockquote>
<p>以下为文章的 <code>Front-matter</code> 示例。</p>
<h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-07 09:25:00</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">typora-vue-theme主题介绍</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-09-07 09:25:00</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">赵奇</span></span><br><span class="line"><span class="attr">img:</span> <span class="string">/source/images/xxx.jpg</span></span><br><span class="line"><span class="attr">top:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">cover:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">coverImg:</span> <span class="string">/images/1.jpg</span></span><br><span class="line"><span class="attr">password:</span> <span class="string">8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92</span></span><br><span class="line"><span class="attr">toc:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">summary:</span> <span class="string">这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Markdown</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Typora</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Markdown</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

<h2 id="效果截图"><a href="#效果截图" class="headerlink" title="效果截图"></a>效果截图</h2><p><img src="http://static.blinkfox.com/matery-20181202-1.png" alt="首页"></p>
<p><img src="http://static.blinkfox.com/matery-20181202-2.png" alt="首页推荐文章"></p>
<p><img src="http://static.blinkfox.com/matery-20181202-3.png" alt="首页文章列表"></p>
<p><img src="http://static.blinkfox.com/matery-20181202-7.png" alt="首页文章列表"></p>
<p><img src="http://static.blinkfox.com/matery-20181202-8.png" alt="首页文章列表"></p>
<h2 id="自定制修改"><a href="#自定制修改" class="headerlink" title="自定制修改"></a>自定制修改</h2><p>在本主题的 <code>_config.yml</code> 中可以修改部分自定义信息，有以下几个部分：</p>
<ul>
<li>菜单</li>
<li>我的梦想</li>
<li>首页的音乐播放器和视频播放器配置</li>
<li>是否显示推荐文章名称和按钮配置</li>
<li><code>favicon</code> 和 <code>Logo</code></li>
<li>个人信息</li>
<li>TOC 目录</li>
<li>文章打赏信息</li>
<li>复制文章内容时追加版权信息</li>
<li>MathJax</li>
<li>文章字数统计、阅读时长</li>
<li>点击页面的’爱心’效果</li>
<li>我的项目</li>
<li>我的技能</li>
<li>我的相册</li>
<li><code>Gitalk</code>、<code>Gitment</code>、<code>Valine</code> 和 <code>disqus</code> 评论配置</li>
<li><a href="http://busuanzi.ibruce.info/">不蒜子统计</a>和谷歌分析（<code>Google Analytics</code>）</li>
<li>默认特色图的集合。当文章没有设置特色图时，本主题会根据文章标题的 <code>hashcode</code> 值取余，来选择展示对应的特色图</li>
</ul>
<p><strong>我认为个人博客应该都有自己的风格和特色</strong>。如果本主题中的诸多功能和主题色彩你不满意，可以在主题中自定义修改，很多更自由的功能和细节点的修改难以在主题的 <code>_config.yml</code> 中完成，需要修改源代码才来完成。以下列出了可能对你有用的地方：</p>
<h3 id="修改主题颜色"><a href="#修改主题颜色" class="headerlink" title="修改主题颜色"></a>修改主题颜色</h3><p>在主题文件的 <code>/source/css/matery.css</code> 文件中，搜索 <code>.bg-color</code> 来修改背景颜色：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 整体背景颜色，包括导航、移动端的导航、页尾、标签页等的背景颜色. */</span></span><br><span class="line"><span class="selector-class">.bg-color</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: <span class="built_in">linear-gradient</span>(to right, #<span class="number">4</span>cbf30 <span class="number">0%</span>, #<span class="number">0</span>f9d58 <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@-webkit-keyframes</span> rainbow &#123;</span><br><span class="line">   <span class="comment">/* 动态切换背景颜色. */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rainbow &#123;</span><br><span class="line">    <span class="comment">/* 动态切换背景颜色. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改-banner-图和文章特色图"><a href="#修改-banner-图和文章特色图" class="headerlink" title="修改 banner 图和文章特色图"></a>修改 banner 图和文章特色图</h3><p>你可以直接在 <code>/source/medias/banner</code> 文件夹中更换你喜欢的 <code>banner</code> 图片，主题代码中是每天动态切换一张，只需 <code>7</code> 张即可。如果你会 <code>JavaScript</code> 代码，可以修改成你自己喜欢切换逻辑，如：随机切换等，<code>banner</code> 切换的代码位置在 <code>/layout/_partial/bg-cover-content.ejs</code> 文件的 <code>&lt;script&gt;&lt;/script&gt;</code> 代码中：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;.bg-cover&#x27;</span>).css(<span class="string">&#x27;background-image&#x27;</span>, <span class="string">&#x27;url(/medias/banner/&#x27;</span> + <span class="keyword">new</span> <span class="built_in">Date</span>().getDay() + <span class="string">&#x27;.jpg)&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>在 <code>/source/medias/featureimages</code> 文件夹中默认有 24 张特色图片，你可以再增加或者减少，并需要在 <code>_config.yml</code> 做同步修改。</p>
]]></content>
      <categories>
        <category>Reference</category>
      </categories>
      <tags>
        <tag>blog</tag>
      </tags>
  </entry>
</search>
