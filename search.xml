<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>矩阵分析-矩阵运算</title>
      <link href="/2020/12/12/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/"/>
      <url>/2020/12/12/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%9F%A9%E9%98%B5%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="表示理论"><a href="#表示理论" class="headerlink" title="表示理论"></a>表示理论</h1><ul><li><p>令v在$(V,F)$中相对于基底${e_1,e_2,⋯,e_n}$的表示为$β$; 令v在$(V, F)$中相对于基底${\bar{e_1},\bar{e_2},⋯,\bar{e_n}}$的表示为$\bar{β}$。</p><script type="math/tex; mode=display">v=[e_1,e_2,...e_n]\beta=E\beta=[\bar{e_1},\bar{e_2},...\bar{e_n}]=\bar{E}\bar{\beta}</script></li><li><p>接上，令$e_i$在$(V,F)$中相对基底${\bar{e_1},\bar{e_2},⋯,\bar{e_n}}$的表示为$[p_{1i},p_{2i},…p_{ni}]^T$; 令$\bar{e_i}$在$(V,F)$中相对基底${e_1,e_2,⋯,e_n}$的表示为$[q_{1i},q_{2i},…q_{ni}]^T$,根据上一条的$v$可得：</p><script type="math/tex; mode=display">\bar{\beta}=P\beta, \beta=Q\bar{\beta}</script><script type="math/tex; mode=display">PQ=I</script></li></ul><hr><h1 id="特征值和特征矩阵"><a href="#特征值和特征矩阵" class="headerlink" title="特征值和特征矩阵"></a>特征值和特征矩阵</h1><h2 id="几何重数-amp-代数重数"><a href="#几何重数-amp-代数重数" class="headerlink" title="几何重数&amp;代数重数"></a>几何重数&amp;代数重数</h2><ul><li>特征值所对应的特征向量所构成空间的维数，称为<strong>几何重数</strong></li><li>这个特征值是几重根，定义了它的<strong>代数重数</strong></li></ul><h2 id="Jordan型"><a href="#Jordan型" class="headerlink" title="Jordan型"></a>Jordan型</h2><ul><li><p>$Jordan$块：当系数取在某个环$\mathbb{R}$上时（其中的零元和乘法单位元分别记为0和1），其对角线上全都是同一个元素$\lambda \in \mathbb{R}$，而对角线上一排（即所有第k行第k+1列）都是1，其余位置上都是0。</p></li><li><p>如果一个分块对角矩阵的每一个分块都是若尔当块，那么这个矩阵叫做若尔当形矩阵，或若尔当标准型。</p></li><li><p>对任意系数域为$\mathbb{K}$的矩阵$\mathbb{M}$,只要其特征值都在$\mathbb{K}$中，就存在一个与之相似的$Jordan$标准型$J$，$M=PJP^{-1}$，其中$P$是一个可逆矩阵，且满足：</p><ol><li>矩阵$J$的特征值（计入重数）就是主对角线上的系数。</li><li>对于$J$的一个特征值$\lambda_i$，它的几何重数就是属于特征值$\lambda_i$的若尔当块的个数</li><li>所有属于特征值$\lambda_i$的若尔当块的维数之和是特征值$\lambda_i$的代数重数</li></ol></li><li><p>上一条可用广义特征向量证明</p></li></ul><h2 id="A-的特征值都不同"><a href="#A-的特征值都不同" class="headerlink" title="$A$的特征值都不同"></a>$A$的特征值都不同</h2><p>$\bar{A}$是特征值在对角线上的矩阵，P是列由<strong>特征向量</strong>构成的矩阵</p><script type="math/tex; mode=display">\bar{A}=P^{-1}AP</script><h2 id="A-有相同的特征值"><a href="#A-有相同的特征值" class="headerlink" title="$A$有相同的特征值"></a>$A$有相同的特征值</h2><ul><li><p>如果$𝑛×𝑛$矩阵$𝐴$中有重复的特征值，则并不总是能找到𝑛个线性无关的特征向量。然而，有可能找到一组特殊的基向量，这样新的 𝐴的表示是块对角形式。(即Jordan标准型)</p></li><li><p>以上的矩阵$P$通过广义特征向量求得，对于$(\lambda-\lambda_i)^{m_i}$则需要找到$m_i$个与特征值$\lambda$相关的线性无关<strong>广义特征向量</strong>：</p><ol><li>计算$(A-\lambda_iI)^i,i=1,2,…k$直到$r(A-\lambda_iI)^k=n-m_i$</li><li>找到基向量$v$使得$(A-\lambda_iI)^kv=0$和$(A-\lambda_iI)^{k-1}v\neq0$</li><li>通过<script type="math/tex; mode=display">v_{k-i}=(A-\lambda_iI)^iv,i=0,1,2,...k-1</script> 生成$k(\leq m_i)$个广义特征向量</li><li>如果$k=m_i$，停止</li><li>如果$k&lt;m_i$,找到另一个基向量$w$满足$2.$的条件, 通过<script type="math/tex; mode=display">w_{l-i}=(A-\lambda_iI)^iw,i=0,1,2,...l-1</script> 生成$l$个广义特征向量</li><li>重复以上过程直到我们找到了$m_i$个特征向量</li></ol></li></ul><hr><h1 id="求矩阵的幂、指数函数"><a href="#求矩阵的幂、指数函数" class="headerlink" title="求矩阵的幂、指数函数"></a>求矩阵的幂、指数函数</h1><h2 id="哈密尔顿–凯莱定理"><a href="#哈密尔顿–凯莱定理" class="headerlink" title="哈密尔顿–凯莱定理"></a>哈密尔顿–凯莱定理</h2><p>给定A为$n\times n$矩阵，A的特征多项式定义为</p><script type="math/tex; mode=display">p(\lambda)=det(\lambda I_n-A)</script><p>则有$p(A)=O$</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ol><li><p>一个2*2矩阵A，特征值多项式为$A^2+cA+d=O$利用此定理$A^2+cA+d=O$,重点引出下述关系</p><script type="math/tex; mode=display">A^2=-cA-d</script><p> 于是有</p><script type="math/tex; mode=display">A^3=(-cA-d)A=-cA^2-dA=c^2A-dA+cd</script><p> 于是$A^k$也可以转化为一次项。</p><p> 一般地：要计算$A^k$,假设$f(A)=A^k=x_1A^{n-1}+x_2A^{n-2}…x_{n-1}A+x_n$,根据特征多项式解出$\lambda_i, i=1,2…k$,代入</p><script type="math/tex; mode=display">\lambda^k=x_1\lambda^{n-1}+x_2\lambda^{n-2}...x_{n-1}\lambda+x_n</script><p> 解方程求出$c,d$便可得$A^n$，求$A$的指数函数同理</p></li><li><p>对于$Jordan$矩阵里的某一个<strong>Jordan块$B$</strong>，显然有</p><script type="math/tex; mode=display">det(\lambda I-B)=(\lambda-\lambda_1)^n=0</script><p> $f(A)$为待求的幂或者指数函数，我们假设在这个<strong>Jordan块$B$内部</strong>有</p><script type="math/tex; mode=display">f(B)=b_0+b_1(\lambda-\lambda_1)+b_2(\lambda-\lambda_1)^2+...+b_{n-1}(\lambda-\lambda_1)^{n-1}</script><p> 由等式左右的各阶导数相等可得</p><script type="math/tex; mode=display">\\ \left\{ \\ \begin{array}{c} b_0=f(\lambda_1) \\  b_1=f^{(1)}(\lambda_1) \\  b_2=\frac{1}{2!}f^{(2)}(\lambda_1) \\ ... \\ b_{n-1}=\frac{1}{(n-1)!}f^{(n-1)}(\lambda_1) \\ \end{array} \\ \right.</script><p> 然后就求出来了</p><script type="math/tex; mode=display">\\     \begin{pmatrix}     f(\lambda_1) & f^{(1)}(\lambda_1)/{1!} & f^{(2)}(\lambda_1)/{2!} & \cdots & f^{(n-1)}(\lambda_1)/{(n-1)!}\\     0 & f(\lambda_1) & f^{(1)}(\lambda_1)/{1!} & \cdots & f^{(n-2)}(\lambda_1)/{(n-2)!} \\     0 & 0 & f(\lambda_1) & \cdots & f^{(n-3)}(\lambda_1)/{(n-3)!} \\     \vdots & \vdots & \vdots & \ddots & \vdots \\     0 & 0 & 0 & \cdots & f(\lambda_1)     \end{pmatrix} \\</script><p> 最后把所有$Jordan$分块求出的结果合成一个矩阵即可</p></li></ol><hr><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      
      
      <categories>
          
          <category> 矩阵分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>矩阵分析-线性空间</title>
      <link href="/2020/12/12/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/"/>
      <url>/2020/12/12/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="向量空间-线性空间"><a href="#向量空间-线性空间" class="headerlink" title="向量空间/线性空间"></a>向量空间/线性空间</h1><p>设V是一个非空集合，F是一个域。若：</p><ol><li>在V中定义了一种运算，称为加法，即对V中任意两个元素α与β都按<strong>某一法则</strong>对应于V内<strong>惟一确定</strong>的一个元素α+β，称为α与β的和。</li><li>在F与V的元素间定义了一种运算，称为数量乘法，即对V中任意元素α和F中任意元素k，都按<strong>某一法则</strong>对应V内<strong>惟一确定</strong>的一个元素kα，称为k与α的积。</li><li>加法与纯量乘法满足以下条件：<ol><li>α+β=β+α，对任意α，β∈V.</li><li>α+(β+γ)=(α+β)+γ，对任意α，β，γ∈V.</li><li>存在一个元素0∈V，对一切α∈V有α+0=α，元素0称为V的零元.</li><li>对任一α∈V，都存在β∈V使α+β=0，β称为α的负元素，记为-α.</li><li>对F中单位元1，有1α=α(α∈V).</li><li>对任意k，l∈F，α∈V有(kl)α=k(lα).</li><li>对任意k，l∈F，α∈V有(k+l)α=kα+lα.</li><li>对任意k∈F，α，β∈V有k(α+β)=kα+kβ，</li></ol></li></ol><p><strong>则称V为域F上的一个线性空间，或向量空间</strong>，若F是实数域$ℝ$，则V称为实数向量空间；若F是复数域$ℂ$，则V称为复数向量空间；若F是有限域，则V称为有限域向量空间。</p><h2 id="度量空间"><a href="#度量空间" class="headerlink" title="度量空间"></a>度量空间</h2><ul><li>如果有映射$X\times X→ℝ$, 且d是在X上的度量运算，则称$(X,d)$为一个度量空间</li><li>度量空间$\forall x,y,z \in X$有以下性质:<ol><li>$d(x,y)\geq 0$ <strong>非负性</strong></li><li>$d(x,x)=0$</li><li>$d(x,y)=d(y,x)$ <strong>对称性</strong></li><li>$d(x,z)\leq d(x,y)+d(y,z)$ <strong>三角不等式</strong></li></ol></li><li>度量空间中的柯西列：给定一个任意度量空间(X,d),一个序列<script type="math/tex; mode=display">x_1,x_2,x_3,...</script>被称为柯西列，如果对于任意正实数$r&gt;0$,存在一个正整数$N$使得对于所有整数$m,n&gt;N$,都有<script type="math/tex; mode=display">d(x_m,x_n)<r</script></li></ul><h2 id="完备度量空间"><a href="#完备度量空间" class="headerlink" title="完备度量空间"></a>完备度量空间</h2><p><strong>完备度量空间</strong>$X$中的任何柯西序列都收敛在该空间$X$一点。</p><ul><li>例子：<ol><li>有理数空间不是完备的，因为$\sqrt {2}$的有限位小数表示是一个柯西序列，但是其极限$\sqrt {2}$不在有理数空间内</li><li>实数空间是完备的</li><li>开区间$(0,1)$不是完备的。序列$(1/2, 1/3, 1/4, 1/5, …)$是柯西序列但其不收敛于$(0,1)$中任何的点。</li></ol></li></ul><h2 id="函数空间"><a href="#函数空间" class="headerlink" title="函数空间"></a>函数空间</h2><p>设(V, F)是一个向量空间，M是所有函数的集合：𝐷→𝑉，其中D是任意集合。M上向量加法定义为：$(f+g)(d)=f(d)+g(d)$, $\forall d \in D, \forall f,g \in M$ &lt;/br&gt;<br>标量乘法定义为：$(af)(d)=af(d)$,  $\forall a \in F, \forall d \in D, \forall f \in M$ &lt;/br&gt;<br>通过这些运算，M是F上的一个向量空间，表示为$(M, F)$</p><h2 id="直接和"><a href="#直接和" class="headerlink" title="直接和"></a>直接和</h2><p>向量空间$V$是子空间$W1$和$W2$的直接和，表示为$V=W1\bigoplus W2$，当且仅当对于$\forall v \in V$，存在v的唯一表达$v=v1\bigoplus v2, v1 \in W1, v2 \in W2$。显然，$W1 \bigcap W2 = \emptyset$。</p><ul><li>理解：二维平面上，x轴是一个一维线性子空间，y轴是另一个一维线性子空间，平面上所有向量都是这两个子空间中各取一个向量由通过向量加法得到，并且这种表示方式是唯一的。<h2 id="赋范向量空间"><a href="#赋范向量空间" class="headerlink" title="赋范向量空间"></a>赋范向量空间</h2></li><li><p>如果函数$||•||：X→ℝ^+$满足：</p><ol><li>$||x||=0$, $if x=0_x(the zero element)$ </li><li>$||ax||=|a||x|$, $\forall x \in X, \forall a \in ℝ$</li><li><p>$||x+y|| \leq ||x||+||y||$</p><p>则称$||•||$,是X上的一个范数，向量空间$(𝑋,ℝ)$则称之为赋范向量空间。<br>注意，是<strong>向量的范数</strong>，$||x||&gt;0$是对向量长度大小的度量，度量就可以由$𝑑(𝑥,𝑦)=||𝑥−𝑦||$定义</p></li></ol></li></ul><h2 id="巴拿赫空间-赋范向量空间-完备性-→Banach-空间"><a href="#巴拿赫空间-赋范向量空间-完备性-→Banach-空间" class="headerlink" title="巴拿赫空间: 赋范向量空间+完备性$→Banach$空间"></a>巴拿赫空间: 赋范向量空间+完备性$→Banach$空间</h2><p>巴拿赫空间是一个具有范数并对此范数完备的向量空间。</p><script type="math/tex; mode=display">x\in ℝ^n, a\in ℝ, x1+x2,</script><script type="math/tex; mode=display">||x1||=\sqrt{x1^Tx1}, d(x1,x2)=||x1-x2||=\sqrt{(x1-x2)^T(x1-x2)}</script><h2 id="内积空间"><a href="#内积空间" class="headerlink" title="内积空间"></a>内积空间</h2><ul><li><p>如果$\forall u,v,w \in W 和 \lambda \in C, (V,C)$下列性质:</p><ol><li>$<u|v>=\overline{<v|u>}$ <strong>共轭对称</strong></li><li>$<u+v|w>=<u|w>+<v|w>, <u|v+w>=<u|v>+<u|w>$ <strong>半双线性</strong></li><li>$&lt;\lambda u|v&gt;= \lambda<u|v>, <u|\lambda v>= \bar{\lambda}<u|v>$ <strong>半双线性</strong></li><li><p>$<u|v> \geq 0$; $<u|u>=0$, $if u=0$ <strong>非负性</strong></p><p>都满足,我们称以下算子为内积：</p><script type="math/tex; mode=display"><•|•>: V\times V → C</script></li></ol></li></ul><ul><li>如果$V$是带有内积的复数内积空间，那么它也是由$||v||=<v|v>^{1/2}$定义范数<script type="math/tex; mode=display">||•||: V→ℝ</script>的赋范向量空间。内积空间也是赋范向量空间和度量空间，<script type="math/tex; mode=display">d(v1,v2)=<v1|v2>^{1/2}</script></li></ul><h2 id="希尔伯特空间-内积空间-完备性-→Hilbert-空间"><a href="#希尔伯特空间-内积空间-完备性-→Hilbert-空间" class="headerlink" title="希尔伯特空间: 内积空间+完备性$→Hilbert$空间"></a>希尔伯特空间: 内积空间+完备性$→Hilbert$空间</h2><ul><li>令复内积空间$V$由定义$||v||=<v|v>^{1/2}, \forall v \in V$赋范，由$d(v,w)=||v-w||=<v-w|v-w>^{1/2}$度量</li><li>如果所有的柯西序列在$V$中都有极限，那么$V$相对于由内积导出的度量是完备的，我们就说$V$是一个希尔伯特(Hilbert)空间。</li></ul><hr><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      
      
      <categories>
          
          <category> 矩阵分析 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的应用总结篇</title>
      <link href="/2020/11/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2020/11/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="一-前中后序遍历相关问题"><a href="#一-前中后序遍历相关问题" class="headerlink" title="一. 前中后序遍历相关问题"></a>一. 前中后序遍历相关问题</h1><h2 id="给定前序和中序求后序"><a href="#给定前序和中序求后序" class="headerlink" title="给定前序和中序求后序"></a>给定前序和中序求后序</h2><ul><li>假设前序字符串是pre，中序字符串是in</li></ul><ol><li>前序遍历总是先访问根，所以当前序列的根总是在前序序列的第一位；</li><li>在中序序列找到此根，据此把中序序列划分成左右两棵子树</li><li>回过来，根据中序划分的左右子树对前序序列除当前根之外的序列进行划分左右子树</li><li>分别dfs左右子树，特别注意l，r的值，都是闭区间</li><li>dfs()遍历完左右子树后输出当前根，这是后序遍历的特点，可以return一下</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l2; i &lt;= r2; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == pre[l1])&#123;</span><br><span class="line">            dfs(l1+<span class="number">1</span>, l1+i-l2, l2, i<span class="number">-1</span>);</span><br><span class="line">            dfs(l1+i-l2+<span class="number">1</span>, r1, i+<span class="number">1</span>, r2);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;pre[l1];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定中序和后序求前序"><a href="#给定中序和后序求前序" class="headerlink" title="给定中序和后序求前序"></a>给定中序和后序求前序</h2><ul><li>假设中序字符串是in，后序字符串是post</li></ul><ol><li>后序遍历总是最后访问根，所以当前序列的根总是在后序序列的最后一位</li><li>在中序序列中找到此根，据此把中序序列划分成左右两棵子树</li><li>回过来，根据中序序列划分的左右子树对后序序列除根之外的序列进行划分</li><li>先访问当前根，这是前序遍历的特点</li><li>分别dfs左右子树</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> l1, <span class="keyword">int</span> r1, <span class="keyword">int</span> l2, <span class="keyword">int</span> r2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = l1; i &lt;= r1; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(in[i] == post[r2])&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;post[r2];</span><br><span class="line">            dfs(l1, i<span class="number">-1</span>, l2, r2-r1<span class="number">-1</span>+i);</span><br><span class="line">            dfs(i+<span class="number">1</span>, r1, r2-r1+i,r2<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定前序和后序求…不会真有人以为能求中序序列吧不会吧不会吧"><a href="#给定前序和后序求…不会真有人以为能求中序序列吧不会吧不会吧" class="headerlink" title="给定前序和后序求…不会真有人以为能求中序序列吧不会吧不会吧"></a>给定前序和后序求…不会真有人以为能求中序序列吧不会吧不会吧</h2><p><a href="https://www.luogu.com.cn/problem/P1229">luogu P1229</a> 题目大意：给出前序和后序序列，问有多少种中序序列<br>容易观察，出现多种中序序列的可能性发生在只有一个儿子的节点上，这是中序遍历的性质</p><ol><li>对于根root, 若仅有一个儿子，有$ans(root) = 2 * ans(root-&gt;son)$</li><li>每遇到单仔节点都会产生新的中序，若有x个单仔节点，$ans = 2^x$</li><li>根据先序遍历和后序遍历的特点，若先序出现”AB”,后序出现”BA”,那么A一定是单仔节点</li><li>小盲点，string在下标越界时不会检查，<strong>返回值都是’\0’</strong></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; post.size(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pre[i] == post[j] &amp;&amp; pre[i+<span class="number">1</span>] == post[j<span class="number">-1</span>] &amp;&amp; i+<span class="number">1</span>&lt;=pre.size() &amp;&amp; j<span class="number">-1</span>&gt;=<span class="number">0</span>)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;(<span class="number">1</span>&lt;&lt;ans)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>矩阵分析-最优化理论笔记</title>
      <link href="/2020/11/10/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/11/10/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E6%9C%80%E4%BC%98%E5%8C%96%E7%90%86%E8%AE%BA%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h1><ul><li>梯度 $grad f(x_0,y_0) = f_x(x_0,y_0)i + f_y(x_0,y_0)j$</li><li>方向导数 $\frac{\partial f}{\partial l} |_{(x_0,y_0)} = e_l^T * gradf(x_0,y_0) = |gradf(x_0,y_0)|cos\theta$, &lt;/br&gt;<br>其中$e_l = (cos\alpha, cos\beta)$,是和$l$同方向的单位向量</li><li>由上可知，$|\theta| \leq 90$时，方向导数，也就是函数沿着$e_l$方向的变化量为正, 函数的变化量是增加的。&lt;/br&gt;<br>于是，梯度方向是函数<strong>增加</strong>最快的方向</li><li>向量函数的Taylor展开:&lt;/br&gt;<br>$F(x)=F(x_\theta)+\Delta F(x)^T | _{x=x_\theta}(x- x_\theta)+ \frac{1}{2}(x- x_\theta)^T\Delta^2F(x)| _{x = x_\theta}(x - x_\theta)+…$ &lt;/br&gt;</li><li>设$A$是$n$阶实对称矩阵，记$\lambda_{max}, \lambda_{min}$分别是$A$中所有特征值中的最大值与最小值,&lt;/br&gt;<br>则$\lambda_{max}X^TX \leq X^TAX \leq \lambda_{min}X^TX$&lt;/br&gt;<br>当$||x||_2 =1$ 时函数$F(x)= x^TAx$ 最大值是 $\lambda _{max}$， 最小值是 $\lambda _{min}$.</li></ul><h2 id="Hessian矩阵相关"><a href="#Hessian矩阵相关" class="headerlink" title="Hessian矩阵相关"></a>Hessian矩阵相关</h2><ol><li>若Hessian阵特征值全为正，则局部有极小值</li><li>若Hessian阵特征值全为负，则局部有极大值</li><li>若Hessian阵特征值有正有负，则局部有鞍点（$x$是$f$一个横截面的局部极大点，却是f另一个横截面的局部极小点）</li><li>若Hessian阵特征值有零，也是不确定的，$x$可以是鞍点或者<strong>平稳谷</strong>的一部分 </li></ol><ul><li>证明—对Hessian矩阵$A$做正交对角化$x=By$, $B$恰好正交对角化$A$, 且有$B^T=B^{-1}$&lt;/br&gt;<br>$x^TAx = y^T\Lambda y = \lambda_1y_1^2+\lambda_2y_2^2+…+\lambda_ny_n^2$&lt;/br&gt;<br>而二阶梯度种二次型的值就取决于Hessian阵的各个特征值是否同时同号&lt;/br&gt;</li></ul><ol><li><p>$F(x)$是二阶连续可导函数时，其混合偏导相等，Hessian矩阵是对称矩阵&lt;/br&gt;<br>对称矩阵的特征向量正交，因此Hessian矩阵的特征向量正交</p></li><li><p>若$F(x)$为二次函数，$\Delta^2F(x)$就是它的Hessian矩阵</p></li><li>$F(x)$在其Hessian矩阵较大特征值对应的特征方向最陡峭，&lt;/br&gt;<br>$F(x)$的曲率为$\frac{p^T\Delta^2F(x)p}{||p||_2^2}, p$为某方向（待求的曲率方向）对于分子项，可根据<strong>数学知识</strong>得，最大值在$F(x)$的Hessian矩阵特征值大的对应的特征向量方向取，最小值同理。 </li></ol><hr><h1 id="下降法"><a href="#下降法" class="headerlink" title="下降法"></a>下降法</h1><h2 id="梯度下降-只利用了一阶梯度信息-lt-br-gt"><a href="#梯度下降-只利用了一阶梯度信息-lt-br-gt" class="headerlink" title="梯度下降 只利用了一阶梯度信息&lt;/br&gt;"></a><strong>梯度下降</strong> 只利用了一阶梯度信息&lt;/br&gt;</h2><ul><li>基本思想是$\Delta x_k = x_{k+1}-x_k = \alpha_k p_k$, 即$x_{k+1} =x_k+\alpha_k p_k$其中$p_k$是搜索 方向, $\alpha_k$ 是学习率。&lt;/br&gt;<br>$F(x)$一阶近似$F(x_{k+1}) = F(x_k+\Delta x_k) \approx F(x_k) +g_k^T \Delta x_k$ &lt;/br&gt;<br>选择$p_k = -g_k$ &lt;/br&gt;<br>有:<strong>$x_{k+1} = x_k-\alpha_k g_k$</strong>&lt;/br&gt;</li></ul><ul><li><p><strong>Tips</strong></p><ul><li>二阶展开的稳定学习率：$\alpha &lt; \frac{2}{\lambda_{max}}$, 其中$\lambda_{max}$是Hessian矩阵的最大特征值</li><li>$\alpha_k$可以选择固定值，也可以每次都沿直线最小化$\alpha_k = \frac{g_k^T g_k}{g_k^T A_k g_k}$, &lt;/br&gt;<br>因为对于$F(x_k-\alpha g_k)=F(x_\theta)-\alpha g_k^Tg^k+\frac{1}{2}\alpha^2g_k^TA_kg_k$, 二次项太大，梯度下降是有可能向上移动的。当$g^TAg$为负或零，近似的泰勒级数表明增加$\alpha$将永远使$F$下降；而如果$g^TAg$为正，使用上面的优化$\alpha$，带入计算可得，一次项和二次型合并得到一个非正值。&lt;/br&gt;</li><li><p>推导: $\frac{dF(x_k-\alpha_k g_k)}{d\alpha_k}=-g_k^Tg_k+\alpha_k g_k^T A_k g_k$，(将$x=x_k-\alpha_k g_k, (x-x_k)=-\alpha_k g_k$代入二阶Taylor展开,再对$\alpha_k$求导)&lt;/br&gt;<br>令其为0即可得$\alpha_k$，即最优步长。</p></li><li><p>$\frac{dF(x_k-\alpha_k g_k)}{d\alpha_k}=\frac{dF(x_{k+1})}{d\alpha_k}=g_{k+1}^T \frac{d(x_k-\alpha_k g_k)}{d\alpha_k}=-g_{k+1}^T g_k$&lt;/br&gt;<br>因为直线最小化需要$\frac{d(F(x_k-\alpha_k g_k))}{d\alpha_k}=0$, 故下一次下降方向与这一次正交。</p></li></ul></li></ul><h2 id="牛顿法-和一阶方法相比，二阶方法使用Hessian矩阵进行优化-lt-br-gt"><a href="#牛顿法-和一阶方法相比，二阶方法使用Hessian矩阵进行优化-lt-br-gt" class="headerlink" title="牛顿法 和一阶方法相比，二阶方法使用Hessian矩阵进行优化&lt;/br&gt;"></a><strong>牛顿法</strong> 和一阶方法相比，二阶方法使用Hessian矩阵进行优化&lt;/br&gt;</h2><ul><li>牛顿法只适用于Hessian矩阵是正定的情况</li><li>$F(x)$二阶近似$F(x_{k+1}) = F(x_k+\Delta x_k) \approx F(x_k) + g_k^T \Delta x_k + \frac{1}{2}\Delta x_k^T A_k \Delta x_k$ &lt;/br&gt;<br>($A_k$就是Hessian矩阵)&lt;/br&gt;<br>对这个近似出来的函数求梯度，然后令梯度为0，得到$g_k+A_k \Delta x_k = 0$($A_k$对称)&lt;/br&gt;<br>于是$\Delta x_k = - A_k^{-1}g_k$&lt;/br&gt;<br>最后$x_{k+1} = x_k - A_k^{-1}g_k$</li></ul><h2 id="共轭梯度法-lt-br-gt"><a href="#共轭梯度法-lt-br-gt" class="headerlink" title="共轭梯度法 &lt;/br&gt;"></a><strong>共轭梯度法</strong> &lt;/br&gt;</h2><ul><li>根据”直线最小化”，$g_{k+1}^T p_k=0$,$p_k$对$p_{k+1}$没有贡献，&lt;/br&gt;<br>下降正交方向的选择不会保持前一搜索方向上的最小值。这产生了锯齿形的结果,&lt;/br&gt;<br>通过遵循每次先搜索结束时的梯度，我们再某种程度上撤销了之前先搜索的方向上取得的进展,&lt;/br&gt;<br>共轭梯度试图解决这个问题。</li><li>针对二次函数$F(x)=\frac{1}{2}x^T A x+d^Tx+c$&lt;/br&gt;<br>$\Delta F(x)=Ax+d, \Delta^2F(x)=A$</li><li>若一组向量$p_k^T,p_j$关于一个正定矩阵A共轭，则$p_k^TAp_j=0, k\neq j$&lt;/br&gt;<br>根据Hessian矩阵特征向量正交，得Hessian矩阵的特征向量共轭</li><li><p>迭代$k$次梯度变化$\Delta g_k=A\Delta x_k$, 又有$\Delta x_k=\alpha_k p_k$&lt;/br&gt;<br>于是共轭条件可以改写:&lt;/br&gt;<br>$p_k^TAp_j=0=\alpha_k p_k^TAp_j=\Delta x_k^TAp_j=(A\Delta x_k)^Tp_j=\Delta g_k^Tp_j, k\neq j$</p></li><li><p>我们寻求$p_k= -g_k^T+\beta_kp_{k-1}$&lt;/br&gt;<br><strong>Fletcher-Reeves</strong>: $\beta_K=\frac{g_k^Tg_k}{g_{k-1}^Tg_{k-1}}$</p></li><li>算法步骤<ol><li>根据初始点$x_0$计算初始梯度/方向$p_0$</li><li>根据直线最小化$\alpha_k = \frac{g_k^T g_k}{g_k^T A_k g_k}$计算步长$\alpha_0$</li><li>根据$x_1=x_0-\alpha_0g_0$更新$x_1$</li><li>根据$x_1$带入函数的梯度求出$g_1$</li><li>根据Fletcher-Reeves计算$\beta_1$</li><li>根据$p_k= -g_k^T+\beta_kp_{k-1}$修正$p_1$</li><li>回到第二步求$\alpha_{k+1}$依次循环</li></ol></li></ul><h1 id="末尾"><a href="#末尾" class="headerlink" title="末尾"></a>末尾</h1>]]></content>
      
      
      <categories>
          
          <category> 矩阵分析 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
